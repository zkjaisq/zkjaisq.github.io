<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>charity</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="charity">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="charity">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="charity">
  
    <link rel="alternate" href="/atom.xml" title="charity" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">charity</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-工作总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/15/工作总结/" class="article-date">
  <time datetime="2018-06-15T15:02:38.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/15/工作总结/">工作总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="记录工作中遇到的一些坑和一些总结"><a href="#记录工作中遇到的一些坑和一些总结" class="headerlink" title="记录工作中遇到的一些坑和一些总结"></a>记录工作中遇到的一些坑和一些总结</h2><ul>
<li>看到一个页面的时候，不是先拿到页面就进行书写的，看到一个页面的时候，就要先进行查看页面的结构，在页面中的时候，看有没有共同的样式，共同的样式要卸载总得里面，首先，如果是一屏的话，<em>body</em>标签就要使用<code>width：100%；height:100%</code>,这样在进行布局的时候就很容易，如果你每个都有公共的外边距的话，最好在他们的腹肌元素上写，这样就可以很好的减少一些冗余的代码。</li>
<li>一个元素如果要增加它的宽度和高度的话，就要使用padding。如果是外边距的话，就要使用的是margin。具体的情况要具体分析。如果是要点击的区域尽量少使用padding，应为有可能会点击到被扩充的区域。PS：当时遇到这个bug的时候是真的被自己给蠢哭的了。</li>
<li>button居中的方法就是在一个父元素使用<code>twxt-align:center</code>,在<code>button</code>中使用<code>margin:0 auto</code>这样就可以是button进行居中。</li>
<li>在工作中样式的问题遇到的是比较多的，还是自己压仔细一些的吧，别太马虎的，这样才能够更好的进行代码的书写。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/06/15/工作总结/" data-id="cjt6ye50h000h34olh1yougd4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网易云音乐思路" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/14/网易云音乐思路/" class="article-date">
  <time datetime="2018-02-14T08:41:33.000Z" itemprop="datePublished">2018-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/14/网易云音乐思路/">网易云音乐思路</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h2><ul>
<li>读懂了七牛的文档和leancloud的文档，创建了数据库。</li>
<li>怎样获取呆歌曲的外链的？就是当你上传完歌曲之后的时候的，会返回一个类似JSON对象的字符串，将这个字符串使用JSON.parse进行转换，包含的有一个hash属性和一个key属性，然后在七牛的管理的会有一个外链默认域名的，你只要在这个域名的后面加上这个key就可以得到这个歌曲的外链。</li>
<li>再获取外链中有一个知识点的，encodeURI和encodeURIComponent的区别：如果是一个完整的网址，你想转义的话就要使用encodeURI,如果是网址的一部分，hi一个查询参数或者是别的什么的，就要使用encodeURIComponent。</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/14/网易云音乐思路/" data-id="cjt6ye50i000i34ol7t44zlkn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-this" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/05/this/" class="article-date">
  <time datetime="2018-02-05T08:27:45.000Z" itemprop="datePublished">2018-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/05/this/">this</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><ul>
<li><p>一直以来this都是令人感觉到比较复杂的，自从学习了什么是this以后一直想写一篇博客来记录this的使用的方法，和this的指向来更好的帮助自己理解this和以后的复习所用的。</p>
</li>
<li><p>在学习的过程中有一句话是必须要记下来的，<strong>call的第一个参数就是this</strong>，如果你是用call的话传入的第一个参数就是this。apply也是，第一个参数就是this，bind的this是绑定的，bind会返回一个硬编码的新函数，他会吧你指定的this设定为参数，并调用新的函数。</p>
</li>
<li><p>下面来看一段代码的吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">console.log(this.count)</span><br><span class="line">&#125;</span><br><span class="line">foo.count=3;</span><br></pre></td></tr></table></figure>
<p>这个时候的this是指向window的，但是还是会依然打印出来3，这是为什么呢，因为在window中没有count这个变量，就会创建一个全局变量count。</p>
</li>
<li><p>this是在运行的时候绑定的，并不是在编写的时候绑定的，它的上下文取决于函数调用时候的各种条件。this的绑定和函数的声明没有任何关系，只取决于函数的调用方式。</p>
</li>
</ul>
<h2 id="this的集中绑定的方式"><a href="#this的集中绑定的方式" class="headerlink" title="this的集中绑定的方式"></a>this的集中绑定的方式</h2><p>1.通常默认的绑定的就是<code>window</code>,看下面的代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fo()&#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">var a = 2</span><br><span class="line">fo()//2</span><br><span class="line">一般的我会把这个看成fo.call(window),fo()前面没有任何函数的调用，可以看成是window.fo(),这样改写成call的模式会更加准确一些的。</span><br></pre></td></tr></table></figure>
<p>2.隐式的绑定this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">var obj=&#123;</span><br><span class="line">  a:3,</span><br><span class="line">  foo:foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()//3</span><br><span class="line">这中就是当foo()被调用的时候，它的钱脉那确实加上了对obj的引用，当函数引用有上下文对象的时候，隐式绑定的规则会把函数调用中的this绑定到这个上下文对象。所以调用foo()的时候，this就被绑定到了obj。</span><br></pre></td></tr></table></figure>
<p>3.显式的绑定</p>
<ul>
<li>就是通过call或者是apply绑定调用的话，那么this的指向就是call或者apply的第一个参数。</li>
</ul>
<p>4.new绑定</p>
<ul>
<li><p>使用new来调用函数（或者说是构造函数的调用的时候）会创建或者是构造一个全新的对象。这个新对象会被执行[[prototype]]连接；这个新对象会绑定到函数调用的this，如果这个函数没有返回值的的话，那么new表达式中的函数调用会返回这个新对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo(a)&#123;</span><br><span class="line">  this.a = a</span><br><span class="line">&#125;</span><br><span class="line">var bar = new foo(2)</span><br><span class="line">console.log(bar.a)//2</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/05/this/" data-id="cjt6ye50l000l34oln3u4x66j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP高级知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/HTTP高级知识/" class="article-date">
  <time datetime="2018-02-03T11:53:17.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/HTTP高级知识/">HTTP高级知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTTP高级知识项目笔记"><a href="#HTTP高级知识项目笔记" class="headerlink" title="HTTP高级知识项目笔记"></a>HTTP高级知识项目笔记</h2><ul>
<li><p>在form表单制作上的问题：</p>
<p>1.form表单中文字的对齐的方式。采用的是<code>text-align：justify；</code>来进行的，我表单的文字是写在li标签的里面的label标签里面的，所以要想让他们对齐就得让他们的宽度是一样的，然后用<code>label::after{content:&#39;&#39;;display:inline-block;width:100%;}</code>,label标签也得进行设置样式的，<code>label{display:inlin-block;text-align:justify;line-height:zzpx;height:xxxpx;overflow:hiddden;}</code>这样就可以让两个字和四个字对齐的了。</p>
</li>
<li><p>接下来就到了我们写JS的时间了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let $form =$(&apos;#formreferring&apos;)</span><br><span class="line">$form.on(&apos;submit&apos;,(x)=&gt;&#123;</span><br><span class="line">    x.preventDefault()</span><br><span class="line">    let hash=&#123;&#125;</span><br><span class="line">    let needs =[&apos;email&apos;,&apos;password&apos;,&apos;password-confirmation&apos;]</span><br><span class="line">    needs.forEach((name)=&gt;&#123; </span><br><span class="line">       let value=$form.find(`[name=$&#123;name&#125;]`).val()</span><br><span class="line">       hash[name] =value</span><br><span class="line">       console.log(hash)</span><br><span class="line">    &#125;)</span><br><span class="line">   $.post(&apos;/sign_up&apos;,hash)</span><br><span class="line">   .then((response)=&gt;&#123;</span><br><span class="line">       console.log(response)</span><br><span class="line">   &#125;,()=&gt;&#123;</span><br><span class="line">       console.log(error)</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">在注册的时候将email、password收集起来并且放在一个hash里面。然后讲hash上传到服务器，服务器再读取上传的数据。因为form表单数据上传是一段一段的，所以要对上传的数据进行处理后才能够进行处理。</span><br><span class="line">  let body = [];</span><br><span class="line">    request.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">      body.push(chunk);</span><br><span class="line">    &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">      body = Buffer.concat(body).toString();</span><br><span class="line">      console.log(body)</span><br><span class="line">    &#125;);</span><br><span class="line">先声明一个数组，然后讲上传的每部分push到数组里面最后将数组连接起变成字符串。</span><br><span class="line">email=1&amp;password=2&amp;password-confirmation=3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">服务端的代码，将上传的数据进行处理变成一个hash</span><br><span class="line">if (path === &apos;/sign_up&apos; &amp;&amp; method === &apos;POST&apos;) &#123;</span><br><span class="line">    let body = [];</span><br><span class="line">    request.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">      body.push(chunk);</span><br><span class="line">    &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">      body = Buffer.concat(body).toString();</span><br><span class="line">      console.log(body)</span><br><span class="line">      let hash=&#123;&#125;</span><br><span class="line">      let string =body.split(&apos;&amp;&apos;)//[&apos;email=1&apos;,&apos;password = 2&apos;,&apos;passwordconfirmation=3&apos;]</span><br><span class="line">      string.forEach((string)=&gt;&#123;</span><br><span class="line">        let part =string.split(&apos;=&apos;)//[&apos;email&apos;,&apos;1&apos;]</span><br><span class="line">        let key =part[0]</span><br><span class="line">        let value=part[1]</span><br><span class="line">        hash[key] =decodeURIComponent(value)</span><br><span class="line">      &#125;)</span><br><span class="line">      console.log(hash)</span><br><span class="line">      response.statusCode = 200</span><br><span class="line">      response.end()</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  decodeURIComponent()将在%40变成一个@符号进行转义。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">前端拿到后端返回JSON对象，如果在后端设置了返回的类型是JSON，jquery就会把类似JSON的字符串变成一个JSON的对象。 </span><br><span class="line"></span><br><span class="line">$.post(&apos;/sign_up&apos;,hash)</span><br><span class="line">   .then((response)=&gt;&#123;</span><br><span class="line">       console.log(response)</span><br><span class="line">   &#125;,(request)=&gt;&#123;</span><br><span class="line">       console.log(request)//是符合JSON对象语法的字符串</span><br><span class="line">       let &#123;errors&#125; = request.responseJSON//创建一个errors的变量，将JSON对象的erroes属性赋值给这个变量。</span><br><span class="line">       console.log(errors)</span><br><span class="line">       if(errors.email &amp;&amp;errors.email === &apos;invalid&apos;)&#123;</span><br><span class="line">        $form.find(&apos;[name = &quot;email&quot;]&apos;).siblings(&apos;.error&apos;).text(&apos;邮箱格式错误&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">后端对提交的表单进行验证如果合格的就存到数据库中去</span><br><span class="line">if(email.indexOf(&apos;@&apos;)=== -1)&#123;</span><br><span class="line">      response.setHeader(&apos;Content-Type&apos;,&apos;application/json;charset = utf-8&apos;)</span><br><span class="line">        response.statusCode =400</span><br><span class="line">        response.write(&apos;&#123;&quot;errors&quot;:&#123;&quot;email&quot;:&quot;invalid&quot;&#125;&#125;&apos;)</span><br><span class="line">      &#125;else if(password !== password_confirmation)&#123;</span><br><span class="line">        response.statusCode =400</span><br><span class="line">        response.write(&apos;password not match&apos;)</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">         var users = fs.readFileSync(&apos;./users&apos;,&apos;utf8&apos;)</span><br><span class="line">        users =JSON.parse(users)//将字符串编程一个数组[]目前只是一个空数组，没有任何的内容，我们需要像里面push内容</span><br><span class="line">        users.push(&#123;email:email,password:password&#125;)</span><br><span class="line">        console.log(users)</span><br><span class="line">        let userString =JSON.stringify(users)</span><br><span class="line">        fs.writeFileSync(&apos;./users&apos;,userString)</span><br><span class="line">        response.statusCode =200</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">对数据进行验证，如果邮箱已经注册了的话，就返回邮箱已经注册，返回400；</span><br><span class="line">var users = fs.readFileSync(&apos;./users&apos;, &apos;utf8&apos;)</span><br><span class="line">        users = JSON.parse(users)//将字符串编程一个数组[]目前只是一个空数组，没有任何的内容，我们需要像里面push内容</span><br><span class="line">        let inUse = false</span><br><span class="line">        for (let i = 0; i &lt; users.length; i++) &#123;</span><br><span class="line">          let user = users[i]</span><br><span class="line">          if (user.email === email) &#123;</span><br><span class="line">            inUse = true</span><br><span class="line">            break</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (inUse) &#123;</span><br><span class="line">          response.statusCode = 400</span><br><span class="line">          response.write(&apos;eamil in use&apos;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          users.push(&#123; email: email, password: password &#125;)</span><br><span class="line">          console.log(users)</span><br><span class="line">          let userString = JSON.stringify(users)</span><br><span class="line">          fs.writeFileSync(&apos;./users&apos;, userString)</span><br><span class="line">          response.statusCode = 200</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      response.end()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">表单登录，登录的时候如果email和password没有填写也要进行前端验证。然后提交表单到服务器</span><br><span class="line">if(hash.email === &apos;&apos;)&#123;</span><br><span class="line">        $form.find(&apos;[name = &quot;email&quot;]&apos;).siblings(&apos;.error&apos;).text(&quot;填写邮箱好吗&quot;)</span><br><span class="line">       return </span><br><span class="line">    &#125;</span><br><span class="line">    if(hash.password === &apos;&apos;)&#123;</span><br><span class="line">        $form.find(&apos;[name = &quot;password&quot;]&apos;).siblings(&apos;.error&apos;).text(&apos;填写密码好吗&apos;)</span><br><span class="line">        return </span><br><span class="line">    &#125;</span><br><span class="line">   $.post(&apos;/sign_in&apos;,hash)</span><br><span class="line">   .then((response)=&gt;&#123;</span><br><span class="line">      window.location.href = &apos;/&apos;</span><br><span class="line">   &#125;,(request)=&gt;&#123;</span><br><span class="line">       console.log(request)//是符合JSON对象语法的字符串</span><br><span class="line">       let &#123;errors&#125; = request.responseJSON//创建一个errors的变量，将JSON对象的erroes属性赋值给这个变量。</span><br><span class="line">       console.log(errors)</span><br><span class="line">       if(errors.email &amp;&amp;errors.email === &apos;invalid&apos;)&#123;</span><br><span class="line">        $form.find(&apos;[name = &quot;email&quot;]&apos;).siblings(&apos;.error&apos;).text(&apos;邮箱格式错误&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">再就是服务器对表单进行验证的时候的事情的了，从数据库中拿到存储的数据，吧提交的表单数据和数据库中的数据进行对比，如果密码和邮箱都正确的话，就登录成功，前端就打开一个登录成功的页面就可以的。：</span><br><span class="line">if(path === &apos;/sign_in&apos;&amp;&amp;method=== &apos;GET&apos;)&#123;</span><br><span class="line">    let string = fs.readFileSync(&apos;./sign_in.html&apos;, &apos;utf8&apos;)</span><br><span class="line">      response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf8&apos;)</span><br><span class="line">      response.write(string)</span><br><span class="line">      response.statusCode = 200</span><br><span class="line">      response.end()</span><br><span class="line">  &#125;else if(path ===&apos;/sign_in&apos;&amp;&amp; method === &apos;POST&apos;)&#123;</span><br><span class="line">    let body = [];</span><br><span class="line">    request.on(&apos;data&apos;, (chunk) =&gt; &#123;</span><br><span class="line">      body.push(chunk);</span><br><span class="line">    &#125;).on(&apos;end&apos;, () =&gt; &#123;</span><br><span class="line">      body = Buffer.concat(body).toString();</span><br><span class="line">      console.log(body)</span><br><span class="line">      let hash = &#123;&#125;</span><br><span class="line">      let string = body.split(&apos;&amp;&apos;)//[&apos;email=1&apos;,&apos;password = 2&apos;,&apos;passwordconfirmation=3&apos;]</span><br><span class="line">      string.forEach((string) =&gt; &#123;</span><br><span class="line">        let part = string.split(&apos;=&apos;)//[&apos;email&apos;,&apos;1&apos;]</span><br><span class="line">        let key = part[0]</span><br><span class="line">        let value = part[1]</span><br><span class="line">        hash[key] = decodeURIComponent(value)</span><br><span class="line">      &#125;)</span><br><span class="line">      console.log(hash)</span><br><span class="line">      let &#123; email, password&#125; = hash</span><br><span class="line">      console.log(email)</span><br><span class="line">      console.log(password)</span><br><span class="line">      var users = fs.readFileSync(&apos;./users&apos;)</span><br><span class="line">      users=JSON.parse(users)</span><br><span class="line">      console.log(users)</span><br><span class="line">      let found</span><br><span class="line">      for(let i=0;i&lt;users.length;i++)&#123;</span><br><span class="line">        if(users[i].email === email &amp;&amp; users[i].password === password)&#123;</span><br><span class="line">          found =true</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(found)&#123;</span><br><span class="line">        response.setHeader(&apos;Set-Cookie&apos;,`sign_inemail=$&#123;email&#125;`)</span><br><span class="line">        response.statusCode = 200</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        response.statusCode = 401</span><br><span class="line">      &#125;</span><br><span class="line">    response.end()</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    前端的处理</span><br><span class="line">    </span><br><span class="line">     $.post(&apos;/sign_in&apos;,hash)</span><br><span class="line">   .then((response)=&gt;&#123;</span><br><span class="line">      window.location.href = &apos;/&apos;</span><br><span class="line">   &#125;,(request)=&gt;&#123;</span><br><span class="line">       console.log(request)//是符合JSON对象语法的字符串</span><br><span class="line">       let &#123;errors&#125; = request.responseJSON//创建一个errors的变量，将JSON对象的erroes属性赋值给这个变量。</span><br><span class="line">       console.log(errors)</span><br><span class="line">       if(errors.email &amp;&amp;errors.email === &apos;invalid&apos;)&#123;</span><br><span class="line">        $form.find(&apos;[name = &quot;email&quot;]&apos;).siblings(&apos;.error&apos;).text(&apos;邮箱格式错误&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>cookie是服务器给返回值设置的一个类似就叫标记的东西吧，我是这么理解的，从此以后当你每次访问和我这个网站同源的网站的时候，<strong>请求的头部</strong>一定会带上这个cookie的。注意cookie是在<strong>请求的头部</strong>。你下次访问的时候就可以不用重新登录了，应为Cookie保存的有你的信息。</p>
</li>
<li><p>Cookie的特点：</p>
<p>1.<strong>服务器通过Set-Cookie 响应头设置Cookie</strong></p>
<p>2.<strong>浏览器得到Cookie之后每次请求的话都要带上Cookie。</strong></p>
<p>3.<strong>服务器读取到Cookie之后就可以知道用户的信息了。</strong></p>
<p>5.<strong>Cookie是可以修改的</strong></p>
<p>6.<strong>Cookie的有效的时长一般在20分钟左右，后端可以强制设置有效期。</strong></p>
<p>7.<strong>Cookie大小限制在4k左右。</strong></p>
<p>8.<strong>Cookie默认在用户关闭页面后就失效了，后台代码可以任意设置Cookie的过期时间的</strong>。</p>
</li>
<li><p>Cookie最大的问题就是可以被篡改，所以在这种情况下就有了Session。</p>
</li>
</ul>
<h3 id="Session和Cookie的区别"><a href="#Session和Cookie的区别" class="headerlink" title="Session和Cookie的区别"></a>Session和Cookie的区别</h3><ul>
<li><p>一般来说Session是基于Cookie来实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cookie的缺点是用户可以随意的篡改的，如果吧用户的邮箱暴露出来，用户篡改了Cookie的话，就可以登录别人的页面，这个时候就存在安全隐患的了。很好的一种解决的方式就是使用Session。</span><br><span class="line">let  sessions =&#123;&#125;</span><br><span class="line"></span><br><span class="line">//在访问路径中写的</span><br><span class="line">let sessionId = Math.random()*100000</span><br><span class="line">sessions[sessionId] = &#123;sign_inemail:email&#125;</span><br><span class="line">response.setHeader(&apos;set-Cookie&apos;,`sessionId =$&#123;sessionId&#125;`)</span><br><span class="line">这样暴露给用户的cookie就是一个随机0-10000之间的一个随机数。</span><br><span class="line">在sessions的hash中保存了sessionId所对应的email，所以的话在用户登录成功以后，要查询到用户的email的话就可以通过let email =sessions[hash.sessionId].sign_inemail</span><br></pre></td></tr></table></figure>
</li>
<li><p>Session:</p>
<p>1.将SessionID（随机数）通过Cookie发送给客户端</p>
<p>2.客户端访问服务器的时候会带上这个Cookie，</p>
<p>3.服务器中有一块内存（哈希表）保存了所有的session</p>
<p>4.通过SessionID可以在哈希表中产训到用户的所有的信息，email、ID等。</p>
<p>5.这块内存（哈希表）就是服务器上的所有session。</p>
</li>
</ul>
<h2 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h2><ul>
<li><p>本质上是浏览器上的一个hash。</p>
</li>
<li><p>localstorage的用法一下几种;</p>
<p>1.<code>localstorage.setItem(&#39;a&#39;,1)</code>,<code>localstorage.getItem(&#39;a&#39;)</code>,<code>locastorage.clear()</code>setItem接受两个参数，getItem接受一个参数，clear不接受参数，将localStorage清空。</p>
</li>
<li><p>localStorage是存在C盘的一个文件里面的了，是一个持久化存储的地方。localStorage的一个最主要的用法就是用来提示信息的。</p>
</li>
<li><p>localStorage的特点：</p>
<p>1.LocalStorage跟HTTP无关的</p>
<p>2.HTTP不会带上LocalStorage的值</p>
<p>3，只有相同域名的页面才能够互相读取LocalStorage</p>
<p>4.每个域名LocalStorage最大储存量是5M左右，字符数限制在500万字符左右。（每个浏览器可以存储的都是不一样的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let already = window.localStorage.getItem(&apos;已经提示过了&apos;)</span><br><span class="line">if(!already)&#123;</span><br><span class="line">  alert(&quot;shenmemem&quot;)</span><br><span class="line">  localStorage.setItem(&apos;已经提示过了&apos;，&apos;true&apos;)</span><br><span class="line">&#125;</span><br><span class="line">这样的话当你下次刷新页面就不会在进行弹出对话框的了。</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>5.常用的场景：记录有没有提示用户（没有用的信息，不能记录密码）</p>
<p>6.LocalStorage永久有效，除非用户清理缓存。</p>
</li>
</ul>
<h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><ul>
<li><p>SessionStorage的特点就是：</p>
<p>1.和HTTP无关</p>
<p>2.HTTP不会带上SessionStorage的值</p>
<p>3.只有相同域名的页面才能够相互读取SessionStorage（但是没有同源那么严格）</p>
<p>4.每个域名的SessionStorage的最大存储量是500万字符左右，每个浏览器的存储的都是不一样的。</p>
<p>5.SessionStorage在页面关闭之后就会失效。</p>
</li>
</ul>
<h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><ul>
<li>缓存控制，如果你请求的页面的内容相同的话，请求的时间就会很快的了。</li>
<li>后台设置Cache-Control的代码`response.setHeader(‘cache-control’,’max-ege=30’);然后在你设置的这段时间内如果你刷新页面的话就不会向浏览器发送请求的。页面的下载时间就是0。</li>
<li>存在的问题就是如果你所有的页面都是设置缓存的话，那么用户在你设置的缓存的时间内就不能狗获取到最新的代码。</li>
<li>如果你要进行更行的话，就要在那个留得入口的地方把那个URL修改一下，在文件后面加一个查询参数啥的，和上次的不一样的就可以。</li>
</ul>
<h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><ul>
<li>这个也是设置缓存的，但是设置的时间是到了那个时间缓存就会被清理掉的，例如`response.setHeader(‘Expires’,’sun 2018’),那么缓存到这个时候就可以呗清理掉的了。而且这个时间是以你本地的时间来进行确认的，一旦你本地的时间有问题的话，这个缓存的时间就会出现问题了。</li>
</ul>
<h2 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h2><ul>
<li><p>想要明白这个就要限制到MD5是什么。MD5是一个斩妖算法。将一个字符串编程另一个字符串的。如果下载的一个文件的MD5不匹配，就说明文件和下载下来的有问题。MD5的文件的差异越小，MD5转换出来的差异越大。</p>
</li>
<li><p>后台代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let fileMD5 = MD5(string)</span><br><span class="line">response.setHeader(&quot;Etag&quot;,&quot;fileMD5&quot;)</span><br></pre></td></tr></table></figure>
<p>然后在你刷新页面的时候请求的头部里面会有一个新的头，就是<code>If-None-Match</code>,这个头对应的内容就是上次返回的文件的MD5的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let fileMD5 = MD5(string)</span><br><span class="line">if(request.header[If-None-Match] ===fileMD5)&#123;</span><br><span class="line">  response.setStatus = 304</span><br><span class="line">&#125;</span><br><span class="line">resposne.setHeader(&quot;Etag&quot;,&quot;fileMD5&quot;)</span><br><span class="line">resposne.end</span><br></pre></td></tr></table></figure>
<p>这个和Cache-Control的区别是Cache-Control是没有发送请求的，而Etag是发送了请求但是没有进行下载的。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/02/03/HTTP高级知识/" data-id="cjt6ye507000534ol6l21tox3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-作用域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/25/作用域/" class="article-date">
  <time datetime="2018-01-25T03:56:38.000Z" itemprop="datePublished">2018-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/25/作用域/">作用域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><ul>
<li><p>函数作用域是指：<strong>属于这个函数的全部变量都可以在整个函数的范围内使用及复用，在嵌套的作用域中也可以使用</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  var a =2</span><br><span class="line">  function boot()&#123;</span><br><span class="line">    var c = 4</span><br><span class="line">  &#125;</span><br><span class="line">  var b =3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* 在函数foo()的作用域中可以使用a、b、但是不能够访问到函数boot里面的变量C,但是在嵌套的boot函数中可以访问到a、b、c三个变量。应为函数foo的变量只有a、b。函数boot的变量只有C，函数boot是嵌套在函数foo中的，所以boot可以使用函数foo中的变量。</span><br></pre></td></tr></table></figure>
</li>
<li><p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/25/作用域/" data-id="cjt6ye50f000e34ol8e4prj0u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flex布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/24/flex布局/" class="article-date">
  <time datetime="2018-01-24T01:00:17.000Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/24/flex布局/">flex布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h1><ul>
<li>flex布局也就是大家常说的弹性布局，是Flexible Box的缩写，用来位盒状模型来提供最大的灵活性。</li>
<li>采用flex布局的元素，简称位Flex容器，它的所有的子元素都自动成为了容器的成员，简称位容器的item也就是项目。</li>
</ul>
<h3 id="真个容器的属性"><a href="#真个容器的属性" class="headerlink" title="真个容器的属性"></a>真个容器的属性</h3><ul>
<li><p>flex-derection属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">属性值：</span><br><span class="line">1.row：主轴位水平方向，起点在左端</span><br><span class="line">2.row-reverse:主轴为水平方向，七点在右端。</span><br><span class="line">3.colum:主轴为垂直方向，起点在上沿。</span><br><span class="line">4.colum-reverse:主轴位垂直方向上的七点在下沿。</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex-wrap属性表示是否换行。wrap表示换行，no-wrap表示不换行，wrap-reverse表示换行，第一行在下方。</p>
</li>
<li><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写，默认值是  row   no-wrap.</p>
</li>
<li><p>Justify-content属性定义了项目（也就是flex里面的子类）在主轴上的对齐方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* flex-start:前对齐</span><br><span class="line">* flex-end:后对齐</span><br><span class="line">* center:居中对齐</span><br><span class="line">* space-between：两端对齐，项目之间的间隔都相等。</span><br><span class="line">* space-around:每个项目两侧的间隔相等。所以项目之间的间隔比项目两边的间隔大一倍。</span><br></pre></td></tr></table></figure>
</li>
<li><p>align-iterms属性是定义项目在交叉轴上如何对齐：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* felx-start:在交叉轴起点对齐</span><br><span class="line">* flex-end:在交叉轴的终点对齐</span><br><span class="line">* center:交叉轴的中点对齐</span><br><span class="line">* baseline:项目中的第一行文字的基线对齐</span><br><span class="line">* stretch:项目没有设置高度或者设置高度位auto，将占满整个容器的高度。</span><br></pre></td></tr></table></figure>
</li>
<li><p>align-content属性定义了多根轴线的对齐方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* felx-start:在交叉轴起点对齐</span><br><span class="line">* flex-end:在交叉轴的终点对齐</span><br><span class="line">* center:与交叉轴的中点对齐。</span><br><span class="line">* space-betweeen:与交叉轴的两段对齐，轴线之间的间隔平均分布。</span><br><span class="line">* sapce-around:每根轴线两侧的间隔都相等。</span><br><span class="line">* stretch：轴线占满整个交叉轴。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="里面子项目的属性"><a href="#里面子项目的属性" class="headerlink" title="里面子项目的属性"></a>里面子项目的属性</h3><ul>
<li>order属性定义了项目的排列顺序。数值越小，排列顺序越靠前，默认的为0.</li>
<li>flex-grow属性定义了项目的放大比例，默认为0，即如果存在剩余的空间，也不放大。</li>
<li>flex-shrink属性定义了项目的缩小比例，默认值是1，即如果空间不足，该项目将缩小。</li>
<li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间，默认值是auto，就是项目本来所占据的空间大小。</li>
<li>align-self属性允许单个项目和其他项目有不同的对齐方式，可以覆盖align-items属性。默认值是auto，表示继承父元素的align-items属性。属性值有：<code>flex-start、flex-end、center、baseline、stretch;</code>这个五个属性。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/24/flex布局/" data-id="cjt6ye50b000a34ol20468ysu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/22/面向对象/" class="article-date">
  <time datetime="2018-01-22T07:19:52.000Z" itemprop="datePublished">2018-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/22/面向对象/">面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li><p>在面向对象编程之中，<strong>类</strong>是对象的模板，定义了同一组对象共有的属性和方法。</p>
</li>
<li><p>构造类的方式</p>
<p>1.构造函数法：<code>function Cat(){this.name = &#39;小猫&#39;}</code>,生成实例的时候，要使用new关键字。类的属性和方法，还可以定义在构造函数的prototype对象之上。</p>
<p>2.Object.creat()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">  name :&quot;大毛&quot;，</span><br><span class="line">  color:function()&#123;alert(&quot;ping&quot;)&#125;</span><br><span class="line">&#125;</span><br><span class="line">var cat1=Object.creat(Cat)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><ul>
<li><p>new的用法</p>
<p>​</p>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/22/面向对象/" data-id="cjt6ye50k000k34ol0te9bv8t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-AJAX和跨域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/AJAX和跨域/" class="article-date">
  <time datetime="2018-01-11T01:19:36.000Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/11/AJAX和跨域/">AJAX和跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><ul>
<li><p>什么是JSONP？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.请求方：一个网站的前端   响应方：服务器</span><br><span class="line">2.请求方动态的创建一个script标签，src指向的是响应方,同时传递一个查询参数?callback = xxxx</span><br><span class="line">3.响应方通过传递的查询参数?callback创建一个形如xxx.call(undefined,&quot;你想要的数据&quot;)</span><br><span class="line">4.请求方接受响应方发出的响应的时候，就会执行xxx.call(undefined.&quot;你想要的参数&quot;)</span><br><span class="line">5.请求方得到了想要的数据，并且删除script。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">请求方的代码：</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-Hans&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;您的账户余额是</span><br><span class="line">        &lt;span id=&quot;amount&quot;&gt;$$$amount$$$&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;button id=&quot;button&quot;&gt;付款&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    button.addEventListener(&apos;click&apos;, (x) =&gt; &#123;</span><br><span class="line">        let script= document.createElement(&apos;script&apos;)</span><br><span class="line">        let functionName = &apos;frank&apos; + parseInt(Math.random()*10000,10)</span><br><span class="line">        //创建一个函数名称，使得传过去的查询参数是一个随机数。</span><br><span class="line">        window[functionName] =(result)=&gt;&#123;</span><br><span class="line">            if(result === &apos;success&apos;)&#123;</span><br><span class="line">                alert(`$&#123;result&#125;`)</span><br><span class="line">                amount.innerText  = amount.innerText - 1</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                alert(faile)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//因为functionName是一个随机数，不确定的因素，所以不能使用functionName.xxx   只能使用[]</span><br><span class="line">        script.src = &apos;http://jack.com:8002/pay?callback=&apos; + functionName//添加查询参数，使得可以知道调用的函数是xxx</span><br><span class="line">        //动态的创建了一个script标签在页面之中。并在成功之后删除该script标签，否则会占用过多的内存。</span><br><span class="line">        document.body.appendChild(script)</span><br><span class="line">        script.onload = function(e)&#123;</span><br><span class="line">            e.currentTarget.remove()</span><br><span class="line">            script.onerror = function(e)&#123;</span><br><span class="line">            e.currentTarget.remove()</span><br><span class="line">            alert(&apos;打钱失败&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       /* image.src = &apos;/pay&apos;</span><br><span class="line">        image.onload=function()&#123;</span><br><span class="line">            alert(&apos;打钱成功&apos;)</span><br><span class="line">            amount.innerText = amount.innerText - 1</span><br><span class="line">        &#125;</span><br><span class="line">        image.onerror =function()&#123;</span><br><span class="line">            alert(&apos;打钱失败failse&apos;)</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">响应方的代码：</span><br><span class="line">if(path === &apos;/pay&apos;)&#123;</span><br><span class="line">    var amount =fs.readFileSync(&apos;./amount&apos;,&apos;utf8&apos;)</span><br><span class="line">    //获取数据库中的amount数据。</span><br><span class="line">    var newAmount = amount - 1</span><br><span class="line">      fs.writeFileSync(&apos;./amount&apos;,newAmount)</span><br><span class="line">      //得到新的数据，并将新的数据存在数据库之中。</span><br><span class="line">      response.setHeader(&apos;Content-Type&apos;, &apos;applycation/script&apos;)</span><br><span class="line">      response.statusCode = 200</span><br><span class="line">	//成功返回状态码200；      response.write(`$&#123;query.callback&#125;.call(undefined,&apos;success&apos;)`)//得到查询参数</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;找不到对应的路径，你需要自行修改 index.js&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面描述的是过程，请求方可以使用jQuery就可以发送JSONP请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&apos;click&apos;, (x) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &quot;http://jack.com:800/pay&quot;,</span><br><span class="line">			// Tell jQuery we&apos;re expecting JSONP</span><br><span class="line">            dataType: &quot;jsonp&quot;,</span><br><span class="line">            // Work with the response</span><br><span class="line">            success: function (response) &#123;</span><br><span class="line">               if(response === &quot;success&quot;)&#123;</span><br><span class="line">                alert(`$&#123;response&#125;`)</span><br><span class="line">                amount.innerText = amount.innerText - 1 </span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                alert(&apos;failse&apos;)</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">* JQuery会帮你创建一个script标签向服务器发送请求，也会创建一个随机的查询参数，也会创建更一个函数，服务器接受到这个函数后并返回这个函数，请求方会调用这个函数。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ul>
<li><p>AJAX发送请求是怎样出现的呢：</p>
<p>1.用form发送请求会刷新页面或重开页面的。(可以发送get请求或者POST请求)</p>
<p>2.使用a标签发送请求GET请求，也会刷新页面，或者重开页面的。</p>
<p>3.用img标签可以发送GET请求，但是只能以图片的形式展示。</p>
<p>4.用link可以发送GET请求，也只能以CSS或者favicon的形式运行，并且link只能放在页面之中才能够运行的。</p>
<p>5.用script发送请求，只能以脚本的形式运行。</p>
</li>
<li><p>什么是AJAX呢：</p>
<p>1.使用XMLHttpRequest发送请求</p>
<p>2.返回的是XML格式的字符串/也可以是别的额类型的字符串代替的XML，也算是AJAX。</p>
<p>3，JS进行解析，并更新局部页面</p>
</li>
<li><p>HTTP中的路径都是绝对路径</p>
</li>
<li><p>使用AJAX发送请求的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest</span><br><span class="line">request.open(&quot;POST&quot;,&quot;/xxx&quot;)//设置请求的路径和请求的格式</span><br><span class="line">request.setHeader()//设置请求的头部。</span><br><span class="line">request.onreadystatechange = (x)=&gt;&#123;</span><br><span class="line">if(request.readystate === 4)&#123;</span><br><span class="line">   let string = request.responseText</span><br><span class="line">  let object = window.JSON.parse(string)</span><br><span class="line">&#125;else</span><br><span class="line">&#125;</span><br><span class="line">request.sed()  //发送请求</span><br></pre></td></tr></table></figure>
</li>
<li><p>readyState中0表示open（）方法还未被调用；1表示send()方法还未被调用；2表示send()方法已经被调用；3表示正在下载，loading；4表示请求完成。响应返回是分不分返回的，并不是一次性返回的。</p>
</li>
<li><p>同源策略：只有当域名、协议、端口号一模一样的时候才叫同源；才能够发送AJAX请求，不是同源的可以通过CORS也能够使用AJAX发送请求。<code>response.setHeader(&#39;Content-type&#39;,&#39;application/javascript;charset =utf-8&#39;)</code>。除了使用CORS还可以使用的是JSONP来进行跨域。</p>
</li>
</ul>
<h2 id="请求的设置"><a href="#请求的设置" class="headerlink" title="请求的设置"></a>请求的设置</h2><ul>
<li>使用XMLHttpRequest来进行发送请求的时候，<code>XMLHttpRequest.open(&#39;请求的方式&#39;，&#39;Host和路径&#39;)</code>,可以使用<code>XMLHtttpRequest.sretRequestHeader(&#39;请求的头部&#39;)</code>来设置请求的头部，接受两个参数，第一个是属性的名字，第二个是value值。<code>XMLHttpRequest.send(body)</code>可以设置请求的第四部分的内容。</li>
</ul>
<h2 id="响应的获取"><a href="#响应的获取" class="headerlink" title="响应的获取"></a>响应的获取</h2><ul>
<li>使用XMLHttpRequest来发送请求后，服务器返回响应。可以通过<code>XMLHttpRequest.getAllResponseHeasers()</code>可以获取所有的响应的头部。如果只想获取其中的一个可以使用<code>XMLHttpRequest.getHeader()</code>;<code>XMLHttpRequest.statusText()</code>可以获取到OK；<code>XMLHttpRequest.status()</code>可以获取到响应的status，一般都是200。获取响应的第四部分可以使用<code>XMLHttpRequest.responseText()</code>。</li>
</ul>
<h2 id="自己封装实现一个ajax"><a href="#自己封装实现一个ajax" class="headerlink" title="自己封装实现一个ajax"></a>自己封装实现一个ajax</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">window.jQuery = function (nodesorSlector) &#123;</span><br><span class="line">    let nodes = &#123;&#125;</span><br><span class="line">    nodes.addClass = function () &#123; &#125;</span><br><span class="line">    nodes.removeClass = function () &#123; &#125;</span><br><span class="line">    return nodes</span><br><span class="line">&#125;</span><br><span class="line">window.$ = window.jQuery</span><br><span class="line">//add a ajax attribute;accept parameter;给jQuery添加了一个ajax的属性，接收的参数。</span><br><span class="line">widnow.jQuery.ajax = function (options) &#123;</span><br><span class="line">    let url = options.url</span><br><span class="line">    let method = options.method</span><br><span class="line">    let body = options.body</span><br><span class="line">    let successFn =options.successFn</span><br><span class="line">    let failFn = options.failFn</span><br><span class="line">    let request = new XMLHttpRequest()</span><br><span class="line">    request.open(&apos;method&apos;, &apos;url&apos;)//配置request</span><br><span class="line">    request.onreadystatechange = () =&gt; &#123;</span><br><span class="line">        if (request.readyState !== 4) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123;</span><br><span class="line">          successFn.call(undefined,request.responseText)</span><br><span class="line">        &#125; else if (request.status &gt;= 400) &#123;</span><br><span class="line">         failFn.call(undefined,request)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    request.send(body)</span><br><span class="line">&#125;</span><br><span class="line">myButton.addEventListener(&apos;click&apos;,()=&gt;&#123;</span><br><span class="line">    window.jQuery.ajax(&#123;</span><br><span class="line">        url:&apos;/xxx&apos;,</span><br><span class="line">        method:&apos;get&apos;,</span><br><span class="line">        body:&apos;1&amp;2&apos;,</span><br><span class="line">        successFn:()=&gt;&#123;console.log(1)&#125;,</span><br><span class="line">        failFn:()=&gt;&#123;console.log(20)&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">  在JS中如果想要给参数命名的话，就可以使用一个对象。一般都是采用这种方式的。因为obj只使用了一次，就可以将这个对象整个传进去。而不使用变量。</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/11/AJAX和跨域/" data-id="cjt6ye50b000934olctr4ufwp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DOM事件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/03/DOM事件/" class="article-date">
  <time datetime="2018-01-03T00:48:09.000Z" itemprop="datePublished">2018-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/03/DOM事件/">DOM事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><ul>
<li><p>事件流描述的是从页面中接收事件的顺序；<strong>冒泡事件就是说事件开始的时候由最具体的元素（文档中嵌套最深的那个节点）接收，然后逐级上传到较为不具体的文档</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;DOCUTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">*如果你点击了页面中的div元素，那么这个click事件的传播顺序：div&gt;body&gt;html&gt;document</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事件捕获：时间捕获是不太具体的节点应该更早的接收到事件，而最具体的节点应该最后接收到事件</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;DOCUTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">* 如果你点击了div元素，那么这个click时间的传播顺序就是document&gt;html&gt;body&gt;div;从最大的到最具体的。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DOM事件流结合时间冒泡和事件捕获，包括时间捕获阶段、处于目标阶段和事件冒泡阶段</strong>。首先发生的是在捕获阶段，为截事件提供了机会，；然后才是实际的目标接受到事件；最后才是冒泡阶段，可以在这个阶段对事件做出响应。DOM2事件规范明确要求捕获阶段不涉及事件目标，也就是只有在冒泡阶段的时候才会进行事件的处理。</p>
</li>
<li><p>​</p>
<p>​</p>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/03/DOM事件/" data-id="cjt6ye501000434olhkbrfsym" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/01/闭包/" class="article-date">
  <time datetime="2018-01-01T01:40:45.000Z" itemprop="datePublished">2018-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/01/闭包/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>什么是闭包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">闭包就是一个函数可以访问到它外部的变量，那么这个函数和这个变量就组成了一个闭包。</span><br><span class="line">function f1()&#123;</span><br><span class="line">  var n =999</span><br><span class="line">  fucntion f2()&#123;</span><br><span class="line">    alert(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的函数f2和n组成了一个闭包。</span><br><span class="line">* 也可以说闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用的方式就是在一个函数的内部创建另一个函数。</span><br><span class="line">function createComparise(propertyName)&#123;</span><br><span class="line">  return function(object1,object2)&#123;</span><br><span class="line">    var value1 = object1[propertuName];</span><br><span class="line">    var value2 = object2[propertyName];//这两个函数访问了函数外的变量proprtyName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在JavaScript中子对象会一级一级的向上寻找所有的父对象的变量，。所以父对象的所有变量对子对象都是可见的，反之子对象的所有变量对于父对象都是不可见的。这就是JavaScript语言特有的『链式作用域』结构。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fucntion f1()&#123;</span><br><span class="line">  var n =999;</span><br><span class="line">  function f2()&#123;</span><br><span class="line">    alert (n)</span><br><span class="line">  &#125;</span><br><span class="line">  return f2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result =f1();</span><br><span class="line">result();//999</span><br><span class="line"></span><br><span class="line">* 在上面的代码中函数f2就是闭包，一般闭包最常用的就是在一个函数中生成另一个函数的，返回一个函数，这样在外部就可以访问到内部的变量了。</span><br></pre></td></tr></table></figure>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><ul>
<li><p>闭包的第一个作用是可以在函数作用域外部读取到函数内部的变量；二就是可以让这些变量可以始终的保存在内存中。还可以封装私有属性和私有方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　function f1()&#123;</span><br><span class="line">　　　　var n=999;</span><br><span class="line">　　　　nAdd=function()&#123;n+=1&#125;</span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return f2;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var result=f1();</span><br><span class="line">　　result(); // 999</span><br><span class="line">　　nAdd();</span><br><span class="line">　　result(); // 1000</span><br><span class="line">* 在这段代码中result一共调用了两次的了，第一次的值是999，第二次的值是1000，这证明的了函数f1中的局部变量n一直保存在变量中，并没有在f1调用后被自动清除。在上面的代码中nAdd=fucntion()&#123;n+=1;&#125;这一行并没有使用var声明，所以是一个全局变量，不是一个局部变量，而且也是一个闭包，可以在函数外部对函数内部的变量进行操作。</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用闭包注意的问题</p>
<p>1.闭包会使函数中的变量保存在内存之中，对内存的消耗很大，不能滥用闭包，否则会造成网页的性能的问题。</p>
<p>2.闭包会在父函数的外部改变函数内部变量的值。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/01/闭包/" data-id="cjt6ye50j000j34olnkwms4p6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/06/15/工作总结/">工作总结</a>
          </li>
        
          <li>
            <a href="/2018/02/14/网易云音乐思路/">网易云音乐思路</a>
          </li>
        
          <li>
            <a href="/2018/02/05/this/">this</a>
          </li>
        
          <li>
            <a href="/2018/02/03/HTTP高级知识/">HTTP高级知识</a>
          </li>
        
          <li>
            <a href="/2018/01/25/作用域/">作用域</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 张科家<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>