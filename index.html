<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>charity</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="charity">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="charity">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="charity">
  
    <link rel="alternate" href="/atom.xml" title="charity" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">charity</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-HTTP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/30/HTTP/" class="article-date">
  <time datetime="2017-12-30T07:40:14.000Z" itemprop="datePublished">2017-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/30/HTTP/">HTTP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>HTTP(HyperTest Transfer Protocol)超文本传输协议。Web使用HTTP的协议作为规范，完成从客户端到服务器端等一系列运作流程，可以说Web是建立在HTTP协议通讯上的。</li>
<li>Tim.Berners-Lee(李爵士)创建了万维网，当时提出了3项WWW的构建技术就是：页面文本的标记语言HTML；作为传输协议的HTTP；指定文档所在地址的URL（Uniform Resource Locator统一资源定位符）。</li>
<li>不同的硬件、操作系统之间的通信之间需要一种规则，我们把这种规则称之为协议（Protocol）。协议中存在各种各样的内容，把互联网相关的协议集合起来总称为TCP/IP。而HTTP则是在TCP/IP协议族的基础上运行的，HTTP属于他内部的一个子集。</li>
<li>IP协议作用就是将各种数据包传递给对方。而要保证确实传送到对方哪里需要满足各种条件，其中最重要的就是IP地址和MAC地址。</li>
<li>IP地址是指明了节点被分配到的地址，是可以变换的，MAC地址（Media Access Control Address）基本上不会更改。</li>
<li>ARP是一种以解析地址的协议；根据通信方的IP地址就可以查到相对应MAC地址。</li>
<li>TCP协议的三次握手是为了确保通信的可靠信，数据的传输过程中。发送端发送一个SYN标志的数据包给对方，接收端收到后，回传一个带有SKN/ACK标志的数据包以表示传达确认信息，最后发送端再回传一个带有ACK标志的数据包，戴白哦握手结束。</li>
<li>DNS(Domain Name System)是和HTTP协议一样位于应用层的协议，提供域名到IP地址之间的解析服务。</li>
</ul>
<h2 id="URI（Uniform-Resource-Identifier）统一资源标识符"><a href="#URI（Uniform-Resource-Identifier）统一资源标识符" class="headerlink" title="URI（Uniform Resource Identifier）统一资源标识符"></a>URI（Uniform Resource Identifier）统一资源标识符</h2><ul>
<li><p>URI就是由某个协议方案表示的资源的定位标识符，协议方案是指访问资源的时候所使用的协议类型的名称。</p>
</li>
<li><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置），由此可见URL是URI的子集。</p>
</li>
<li><p>URI包括URL和URN，其中URL就是我们常说的网址。</p>
</li>
<li><p>URL包括：</p>
<p>1.协议（一般是http/https协议）</p>
<p>2.域名：www.baidu.com，顶级域名是最后一个.右边部分，二级域名是一次往下输的就是，.com是顶级域名，baidu是二级域名，www是三级域名。</p>
<p>3.端口号：一般是80</p>
<p>4.路径：</p>
<p>5.查询参数？。。。。</p>
<p>6.锚点：</p>
</li>
</ul>
<h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><ul>
<li><p>客户端和服务器通过HTTP协议进行交互</p>
</li>
<li><p>浏览器发起请求，服务器在80端口接受请求，服务器返回内容(响应)，浏览器负责下载响应的内容。HTTP的作用就是直到浏览器和服务i去如何进行沟通。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1 动词 路径 协议/版本</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Key3: value3</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line">3 </span><br><span class="line">4 要上传的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Frank: xxx</span><br><span class="line"></span><br><span class="line">curl -X POST -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Frank: xxx</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">1234567890</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应的格和内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 2443</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Tue, 10 Oct 2017 09:14:05 GMT</span><br><span class="line">Etag: &quot;5886041d-98b&quot;</span><br><span class="line">Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line">Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 协议/版本号 状态码 状态解释</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Content-Length: 17931</span><br><span class="line">2 Content-Type: text/html</span><br><span class="line">3</span><br><span class="line">4 要下载的内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP状态码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* 1xxx不常用，表示接受的请求正在处理</span><br><span class="line">* 2xx表示成功</span><br><span class="line">	2.200表示客户端发来的请求在服务器端被正常的处理。</span><br><span class="line">	2.204代表服务器接受的请求已成功的处理，但在返回的响应报文中不包含实体的主题部分。</span><br><span class="line">	3.206表示客户端进行了范围请求，服务器成功的执行了这部分的请求。</span><br><span class="line">* 3xx表示重定向</span><br><span class="line">	1.301永久性重定向，该状态码表示请求的资源已经被分配了新的URL以后应该使用资源现在所指定的URL，</span><br><span class="line">	2.302临时性重定向，该状态码表示请求的资源已经被分配了新的URL，希望用户本次使用新的URI访问。</span><br><span class="line">	3.303该状态码表示请求对应的资源存在着另一个URL，应该使用GET方法定向获取请求的资源。</span><br><span class="line">	4.304该状态码表示客户端发送附带条件的请求的时候，服务器端允许请求访问资源。单因发生请求请求未满足条件的情况后，直接返回304Not Modefied。</span><br><span class="line">	5.307表示临时重定向，</span><br><span class="line">* 4xx表示客户端的错误</span><br><span class="line">	1.400该状态码表示请求报文中存在着语法错误。当错误发生时应该修改请求的内容后再次发送请求。</span><br><span class="line">	2.401该状态码表示发送的请求需要有HTTP认证的认证消息。另外若之前已经进行过一次请求，则表示用户认证失败。</span><br><span class="line">	3.403Forbidden该状态码表示对请求资源的访问被服务器拒绝了。</span><br><span class="line">	4.404 Not Found表示服务器上没有请求的资源。</span><br><span class="line">* 5xx表示服务器错误</span><br><span class="line">	1，500改状态吗表示服务器在执行请求的时候发生错误，</span><br><span class="line">	2.503改状态码表示服务器暂时处于超负荷或正在进行停机维护。</span><br></pre></td></tr></table></figure>
</li>
<li><p>从输入URL到页面加载显示完成都发生了什么:</p>
<p>1.浏览器根据域名查找对应的IP地址，也就是DNS解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 每个域名都对应了一个或者多个提供相同服务的IP地址，只有直到服务器的IP地址才能够建立连接，所以需要桶过DNS把域名解析成一个IP地址。域名的解析过程是递归查询的，首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会想根域名服务器发送一个请求，如果根域名服务器也不存在该域名的时候，本地域名会向com顶级域名服务器发送一个请求，如果顶级域名服务器没有就会到耳机域名服务器查询，以此类推，直到最后本地域名服务器得到了域名的IP地址并把它缓存到本地，供下次查询使用。</span><br><span class="line">* DNS缓存，DNS存在着多级缓存，从离浏览器的距离排序的话可以分为：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存，主域名服务器缓存。</span><br><span class="line">* DNS负载均衡：真实的互联网的有很多的服务器，你每次访问网站的IP地址都是不一样的。DNS返回一个合适的机器的IP地址给用户，例如根据每台机器的负载量，该机器距离用户地理位置等。</span><br></pre></td></tr></table></figure>
<p>2.TCP连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 浏览器于服务器之间通过三次握手建立TCP连接；为什么要建立三次握手呢，原因是两次握手不可靠。原因是两次握手不可靠。比如，浏览器发送一个连接请求包A，但包A在半路上堵车了，浏览器就认为包A丢失了，所以重新发生一个请求包B给服务器。服务器收到请求，建立连接。两端进行通信，结束后关闭连接。但是这时候，包A到达了服务器，服务器不知道这是一个无效的包，所以进行响应。这时两次握手已经完成，两端就建立起一个无效的连接。但浏览器认为自己没发出请求，所以不会回应，这样就让服务器白白等待回应，浪费了服务器资源。而三次握手的机制下，浏览器知道自己并没有请求连接，会发送拒绝包给服务器，服务器收到回应后也会结束这次无效的连接。</span><br></pre></td></tr></table></figure>
<p>3.浏览器向服务器发送HTTP请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure>
<p>4.服务器接受到请求，从它的文档空间中查找资源并返回HTTP响应</p>
<p>5.浏览器接受HTTP响应，检查HTTP header里面的状态码，并做出不同的处理方式。如果是可以缓存的，这个响应则会被存储下来。</p>
<p>6.解码：浏览器拿到文件后，开始解析其中的html代码，遇到js/css/image等静态资源的时候就向服务器端去请求下载。</p>
<p>7.渲染：</p>
<p>8.关闭TCP连接或继续保持连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 通过四次挥手关闭连接：第一次挥手是浏览器发完数据后，发送FIN请求断开连接。第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。这样浏览器需要返回ACK表示同意，也就是第四次挥手。</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/30/HTTP/" data-id="cjbviyeaw0003ilolacvp9m5e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/22/jQuery-1/" class="article-date">
  <time datetime="2017-12-22T09:24:15.000Z" itemprop="datePublished">2017-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/22/jQuery-1/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="jQuery和DOM之间的转换"><a href="#jQuery和DOM之间的转换" class="headerlink" title="jQuery和DOM之间的转换"></a>jQuery和DOM之间的转换</h2><ul>
<li>DOM对象和jQuery之间的转换，DOM对象可以通过jQuery进行包装成jQuery对象，$()，就可以将DOM对象包装成jQuery对象的了。jQuery对象通过[index]的方式可以将jQuery对象抓换位DOM对象。$(div)[0]=div,可以这样进行转换。</li>
<li>全局变量尽量少用，尽量使用局部变量。声明一个函数立即执行，function f(){}.call()，这样可以，局部变量的作用域只是在函数的内部，在函数 外面就不能访问到函数里面的变量。但是创建了一个函数并且立即执行这样浏览器会报错的，在function前面加一些符号就可以避免这个错误的了，还可以使用的是，{let a=1}用一个代码块，使用<code>let</code>来声明一个变量。在这个代码块外面如果没有声明a，console.log(a)会打印出undefined。</li>
</ul>
<h2 id="轮播的思路"><a href="#轮播的思路" class="headerlink" title="轮播的思路"></a>轮播的思路</h2><ul>
<li><p>让所有的轮播图在一行里面，轮播图窗口的大小就是一张图片的大小，在窗口之外的图片使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 使用jQuery获取到所有的元素，找到所有点击的图标的下标，每个看每个移动的距离乘以得到的下标就是每个图片所需要移动的距离。</span><br><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure></p>
<p>var buttons = $(‘#button &gt; span’)<br>var n = 0;<br>//.eq意思是找出对应的DOM对象，并封装成一个jQuery对象。<br>buttons.eq(n % 3).trigger(‘click’).addClass(‘red’)<br>.siblings(‘.red’).removeClass(‘red’)<br>var timerId = setInterval(() =&gt; {<br>   n += 1<br>   buttons.eq(n % 3).trigger(‘click’).addClass(‘red’)<br>   .siblings(‘.red’).removeClass(‘red’)<br>}, 1000)<br>$(‘.screen’).on(‘mouseenter’, function () {</p>
<pre><code>window.clearInterval(timerId)
</code></pre><p>})<br>$(‘.screen’).on(‘mouseleave’, function () {</p>
<pre><code>timerId = setInterval(() =&gt; {
    n += 1
    buttons.eq(n % 3).trigger(&apos;click&apos;).addClass(&apos;red&apos;)
        .siblings(&apos;.red&apos;).removeClass(&apos;red&apos;)
}, 1000)
</code></pre><p>})<br>```</p>
</li>
</ul>
<h2 id="写代码的原则"><a href="#写代码的原则" class="headerlink" title="写代码的原则"></a>写代码的原则</h2><ul>
<li>JS内容、样式、行为的分离。其中HTML负责内容，CSS负责样式，JavaScript负责行为，这是写代码的原则。但是原则有时候也可以打破的，不是一定必须要这么坚持的原则，但是坚持原则也是比较好的一种行为的。</li>
</ul>
<h2 id="无缝轮播的思路"><a href="#无缝轮播的思路" class="headerlink" title="无缝轮播的思路"></a>无缝轮播的思路</h2><ul>
<li>联想到生活中的跳绳，先让图片排成一排，然后再每个都从敞口过一遍，之后呢，每个再回到第一次的位置，就这样一直轮着下去，就实现一个无缝的轮播，这样要使用的display：absolute；使每个图片都不相互干扰。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/22/jQuery-1/" data-id="cjbviyeaz0007ilol45vxcae3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/18/jQuery/" class="article-date">
  <time datetime="2017-12-18T04:45:55.000Z" itemprop="datePublished">2017-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/18/jQuery/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自己实现一个jQuery的思路和代码"><a href="#自己实现一个jQuery的思路和代码" class="headerlink" title="自己实现一个jQuery的思路和代码"></a>自己实现一个jQuery的思路和代码</h2><ul>
<li>自己实现一个API的思路和代码</li>
</ul>
<ul>
<li><p>1.包装两个函数，添加一个className和获取一个文本内容</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function addClass(node,className)&#123;  className.forEach((value)=&gt;node.classList.add(value))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function text(node)&#123;</span><br><span class="line"></span><br><span class="line">  return text =node.innerText</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addClass(iterm1,[1,2,3])</span><br><span class="line"></span><br><span class="line">console.log(text(iterm3))</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>2.给函数起一个名字，可以用命名空间来取windon.zkjDOM={};zkjDOM.addClass=addClass;zkjDOM.text=text;有可能别人也起了一个这样的函数名字，就把别人的函数给覆盖了；还可以直接将函数添加到Node.prototype中去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Node.prototype.addClass = function (node,className)&#123;  className.forEach((value)=&gt;node.classList.add(value))&#125;,还可以新建一个Node，window.Node2 =function(node)&#123;return addClass:&#123;&#125;,text:&#123;&#125;&#125;,</span><br><span class="line">  window.Node2 = function(node)&#123;</span><br><span class="line">    return&#123;addClass: function(className)&#123;className.forEach((value) =&gt; node.classList.add(value))&#125;,</span><br><span class="line">  getText : function()&#123;return text = node.textContent&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用字符串去查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">window.Node2 = function(nodeorSelector)&#123;</span><br><span class="line"></span><br><span class="line">let node</span><br><span class="line"></span><br><span class="line">  if(typeof nodeorSelector===&apos;string&apos;)&#123;</span><br><span class="line"></span><br><span class="line">node = document.querySelector(nodeorSelector)</span><br><span class="line"></span><br><span class="line">  &#125;else if(nodeorSelector instanceof Node)&#123;</span><br><span class="line"></span><br><span class="line">node =nodeSelector&#125;</span><br><span class="line"></span><br><span class="line">return&#123;</span><br><span class="line"></span><br><span class="line">addClass: function(className)&#123;</span><br><span class="line"></span><br><span class="line">className.forEach((value) =&gt; node.classList.add(value))</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getText : function()&#123;return text = node.textContent</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var node2 = Node2(&quot;#iterm2&quot;)</span><br><span class="line"></span><br><span class="line">node2.addClass([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])</span><br><span class="line"></span><br><span class="line">console.log(node2.getText())</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><p>可以查找多个并：</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- window.jQuery = function(nodeorSelector)&#123;</span><br><span class="line">  let nodes=&#123;&#125;</span><br><span class="line">  if(typeof nodeorSelector===&apos;string&apos;)&#123;</span><br><span class="line">  let temp = document.querySelectorAll(nodeorSelector)</span><br><span class="line">  for(let i= 0;i&lt;temp.length;i++)&#123;</span><br><span class="line">  nodes[i]=temp[i]</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.length = temp.length</span><br><span class="line">  &#125;else if(nodeorSelector instanceof Node)&#123;</span><br><span class="line">  node =&#123;0:nodeorSelector,length:1&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = function(className)&#123;className.forEach((value) =&gt; &#123;</span><br><span class="line">  for(let i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">  nodes[i].classList.add(value)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.getText =function()&#123;</span><br><span class="line">  let texts =[]</span><br><span class="line">  for(let i=0;i&lt; nodes.length;i++)&#123;</span><br><span class="line">  texts.push(nodes[i].innerText)</span><br><span class="line">  &#125;</span><br><span class="line">  return texts</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText =function(text)&#123;</span><br><span class="line">  for(i=0;i &lt; nodes.length;i++)&#123;</span><br><span class="line">  nodes[i].innerText = text</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  return nodes</span><br><span class="line">  &#125;</span><br><span class="line">  var node2 = jQuery(&quot;div&quot;)</span><br><span class="line">  console.log(node2)</span><br><span class="line">  node2.addClass([&apos;a&apos;])</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/18/jQuery/" data-id="cjbviyeb00008iloluo386hvh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/14/DOM/" class="article-date">
  <time datetime="2017-12-14T11:40:50.000Z" itemprop="datePublished">2017-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/14/DOM/">DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li><p>DOM是JavaScript操作网页的接口，全称为Document Object Model，也就是文档对象模型，它的作用试讲网页转为一个JavaScript对象，从而可以用脚本进行各种操作。浏览器会根据DOM模型，将结构化文档解析成一系列的节点，再由这些节点组成一个树状结构，也就是DOM tree。</p>
</li>
<li><p>节点的类型有七种类型：</p>
<p>1.Document类型整个文档树的顶层节点</p>
<p>2.DocumentType:doctype标签，比如&lt;!DOCTYPE html&gt;</p>
<p>3.Element:网页的各种HTML标签</p>
<p>4.Attribute：网页元素的属性（如class:’right’）</p>
<p>5.Text:标签之间或标签包含的文本</p>
<p>6.Comment:注释</p>
<p>7.DocumentFragment:文档的片段</p>
</li>
<li><p>DOM的最小组成单位是节点node。最顶层的节点就是document节点，它代表了整个文档。文档里面的最高一层的HTML标签，一班是<code>&lt;html&gt;</code>，它构成了树结构的根节点（root node），其他HTML标签节点都是它的下级。</p>
</li>
<li><p>页面中的节点通过构造函数构造出对应的对象，这就是DOM的主要功能。</p>
</li>
<li><p>Node的属性</p>
<p>1.childNodes表示所有的子节点</p>
<p>2.nodeName返回的都是字符串，除了svg以外，所有的都是大写的返回值。</p>
<p>3.获取html要使用<code>document.document.element</code>,</p>
<p>4.nodeType，值是1的时候表示的是element，值是3的时候表示的是Text，值是9的时候表示document。</p>
<p>5.innertext只会获取文本，而textContent除了获取文本以外还会获取script和style元素。</p>
<p>6.cloneNode表示克隆节点，后面接受一个参数表示是否接受深拷贝。true表示接受，false表示不接受深拷贝。</p>
<p>7.isEqualNode表示相等的两个节点，isSameNode表示相同的两个节点，可以理解位就是同一个节点才会是相同的。</p>
<p>8.removeChild表示移除子节点，但是还是会在内存中，可以被调用的。</p>
</li>
<li><p>Docucment接口：</p>
<p>1.body获取body元素</p>
<p>2.characterSet获取字符编码</p>
<p>3.documentElement获取的就是html元素，是文档的根元素。</p>
<p>4.document.domain获取你的域名</p>
<p>5.document.links获取页面中所有的a标签。</p>
<p>6.document.plugins获取是否装了插件</p>
<p>7.referrer引荐人</p>
<p>8.visibilityStates表示页面是否可以显示</p>
<p>9.document.execCommand（）表示执行命令</p>
<p>10.document.qurySelector()返回一个元素，但是document.querySelectorAll()返回的是一个伪数组，不管里面的有几个都是一个伪数组，原型指向的是NodeLise.prototype</p>
</li>
<li><p>element接口</p>
<p>1.attribute返回一个和该元素相关的所有属性的集合</p>
<p>2.accessKey设置一个按键，用户桶过敲击这个按键吧焦点跳转到这个元素上。</p>
<p>3.clientLeft表示一个元素左边框的宽度</p>
<p>4.clientTop获取一个元素顶部的距离</p>
<p>5.innerHTML和textContent的区别是textContent只获取到文本，innerHTML是可以获取到里面的标签。</p>
<p>6.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/14/DOM/" data-id="cjbviyeat0001ilol88akcp82" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/11/Array/" class="article-date">
  <time datetime="2017-12-11T05:26:10.000Z" itemprop="datePublished">2017-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/11/Array/">Array</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ul>
<li>数组就是一组有序集合，在JS中的数组就是原型链中有Array.prototype的对象。数组恩每个值都有自己对应的编号(从0开始)，整个数组用方括号表示。</li>
<li>生成数组的方式有两种：一种是直接用[]来生成，第二种是使用new Array来生成数组，这两种方法生成的。其中使用new Array和使用Array来生成数组是一样的。</li>
<li>有一点是要注意的，当使用Array构造汗数来生成数组的时候，当你传入的参数位一个的时候，这个时候你只能生成一个length为传入参数的空数组，每一项的值都是undefined。当你传入的参数多于一个的时候生成的数组的值就是你穿如的参数，数组的length就是你穿如参数的个数。</li>
<li>![Alt  text][./数组.png]</li>
</ul>
<h3 id="函数声明的方式"><a href="#函数声明的方式" class="headerlink" title="函数声明的方式"></a>函数声明的方式</h3><p>1.具名函数</p>
<figure class="highlight plain"><figcaption><span>f (x,y)&#123;return x + y&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.匿名函数加var</p>
<figure class="highlight plain"><figcaption><span>f ; f </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.具名函数加var </p>
<figure class="highlight plain"><figcaption><span>f1 ; f1 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.window.Function +var </p>
<figure class="highlight plain"><figcaption><span>f ; f </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.箭头函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h2><ul>
<li>什么是伪数组：就是有0，1，2，3，4，5…..n，length这些key的对象，但是原型链中没有Array.prototype。目前直到的伪数组有arguments对象，和document.querySelectAll返回的对象。</li>
</ul>
<h2 id="数组中的API"><a href="#数组中的API" class="headerlink" title="数组中的API"></a>数组中的API</h2><ul>
<li>Array.peototype.forEach,后面接一个函数，表示对数组中的每一个元素执行一次所对应的函数。</li>
<li>Array,prototype.Sort后面接一个函数，函数接受两个参数，分别是数组中的两个值，返回值位两个值的差。如果大于0 则按照从小到大的顺序对数组进行排列，如果小于0的话，则按照从大到小的顺序排列。</li>
<li>Array.prototype.join用于将一个数组的所有元素连接到一个字符串中，返回值是一个字符串。</li>
<li>Array.prototype.Concat用于节哀那个两个数组合并为一个数组，返回一个新的数组，但不会更改现有的数组。</li>
<li>Array.prototype.toString用于将一个数组转为字符串</li>
<li>Array.prototype.map用于创建一个新数组，七街狗是该数组中的每一个元素都调用一个提供的函数后返回的结果。</li>
<li>Array.prototype.filter后面接一个函数，用来将一个数组特定的值过滤出来。</li>
<li>Array.prototype.reduce后面接一个函数，接两个参数，第一个是前面累加的值，第二个是正咋处理的元素，这个API的用法就是用来求和的，你可以将这个想象成抢劫的应用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/11/Array/" data-id="cjbviyeap0000ilolrapj76pw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/10/对象/" class="article-date">
  <time datetime="2017-12-10T04:25:56.000Z" itemprop="datePublished">2017-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/10/对象/">JS中的对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS中的对象"><a href="#JS中的对象" class="headerlink" title="JS中的对象"></a>JS中的对象</h1><h2 id="什么是全局对象和全局变量"><a href="#什么是全局对象和全局变量" class="headerlink" title="什么是全局对象和全局变量"></a>什么是全局对象和全局变量</h2><ul>
<li><p>ECMAScript中规定全局对象是global，但是在浏览器中全局对象是window，不管你在哪个网页一定可以访问到一个对象，就是window。window是一个hash表，有很多属性，这些属性就是全局对象。</p>
</li>
<li><p>window中的属性包含两种，一种是ECMAScript规定的，不管是在Node.js还是在浏览器中都要有这些属性；另一种则是浏览器私有的，就是在某些浏览器中才有的一些属性。每个浏览器的私有属性的标准都是不一样的，因为没有标准的规定，所以不一样。</p>
<p>1.ECMAScript规定的</p>
<ul>
<li>global.parseInt      (将字符串转为数字，接受两个参数，第一个是要转换的字符串，第二是转换的进制数)</li>
</ul>
</li>
</ul>
<ul>
<li>global.parseFloat    (将字符串转为浮点数)</li>
</ul>
<ul>
<li>global.Number    (将别的类型的值转为Number  数字)</li>
<li>Global.String    (将别的类型的值转为String 字符串)</li>
<li>global.Boolean   (将别的类型的值转为Boolean 布尔值)</li>
<li><p>global.Object    (将别的类型的值转为Object 对象)</p>
<p>2.浏览器自己加的属性</p>
</li>
</ul>
<ul>
<li>window.alert   (弹框提示)</li>
<li>window.promt  (让用户填东西)</li>
<li>window.confirm  (让用户确认)</li>
<li>window.console.log   (让开发者打印东西)</li>
<li>window.console.dir  (打印出对象所有的属性)</li>
<li>window.document (也有自己的规范也就是DOM，是由W3C指定的规范)</li>
<li>window.document.createElement (再文档中创建新的元素)</li>
<li>window.docuemnt.getElementById   (获取文档中有这个id的元素)</li>
</ul>
<h2 id="JS中简单类型和对象的区别"><a href="#JS中简单类型和对象的区别" class="headerlink" title="JS中简单类型和对象的区别"></a>JS中简单类型和对象的区别</h2><ul>
<li><p>Number的用法有两种：</p>
<p>1.将一个字符串”1”转换位数字1</p>
<p>2.作为一个构造函数创建一个对象1，<code>var n = new Number(1)</code></p>
</li>
<li><p>简单类型的1和对象的的区别是在内存中,简单类型的1是直接存在stack内存中的，而对象1在stack中存了这个对象地址，而对象是存在heap内存中的，，这个对象其实是一个hash，包含了Number对象的各种属性，这个对象1要调用对象中的属性时，就通过stack中的地址找到heap中的对象，使用对象中的属性。那么简单类型的1为什么也可以使用Number中的属性呢？原因就是在简单类型1使用Number的方法的时候，会将简单类型1封装成一个临时对象，然后再调用Number对象中的属性。这个临时的对象在使用完成以后会被删除回收掉。</p>
</li>
<li><p>String的用法也是有两种：</p>
<p>1.将一个别的类型的值转为字符串</p>
<p>2.作为构造函数，创建一个字符串对象 <code>var s = new String(&#39;sdkkhfkdljfk&#39;)</code>;这个对象中有很多的属性，<code>s.charAt(1) =d</code>获取某一个索引对应的字符，s.<code>charCodeAt(0)=115</code>,获取某个索引对应字符的Unicode编码的数字，<code>(100).toString(16) = 64</code>表示将数字100转为16进制位64。<code>trim(),&#39;   username  &#39;.trim();返回值为&quot;username&quot;去掉字符串中的空格</code>，<code>concat()连接两个字符串，var s= &#39;hello&#39;; var s1 = &#39;world&#39;; s.concat(s1)=&#39;hello world&#39;</code>,<code>var a = &#39;hello&#39;; a.slice(0,3)返回&quot;hel&quot;</code>,<code>var a = &#39;hello&#39;;e.replace(&#39;o&#39;);返回&quot;hollo&quot;</code>。</p>
</li>
<li><p>Boolean的用法也是两种：</p>
<p>1.将别的类型转为布尔值，其中五个falsy值，”0”、”AaN”、””(空字符串)、”null”、”undefined”;</p>
<p>2.作为构造函数，穿件一个对象，所有的对象都是true,</p>
</li>
<li><p>Object:就是创建一个函数。</p>
</li>
</ul>
<h2 id="共有属性"><a href="#共有属性" class="headerlink" title="共有属性"></a>共有属性</h2><ul>
<li>String.prototype是String的公有属性的引用，如果没有就不能引用String的共有属性，会被垃圾回收，而<code>s.__proto__</code>是为了要使用String的公有属性，如果没有<code>__proto__</code>就不能够引用String的共有属性。</li>
<li><img src="/Users/kejia/Desktop/JS中的对象.png" alt="JS中的对象"></li>
<li>​</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/10/对象/" data-id="cjbviyeb2000ailolhqy65e8f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/09/函数/" class="article-date">
  <time datetime="2017-12-09T08:05:28.000Z" itemprop="datePublished">2017-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/09/函数/">函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数声明的物种方式"><a href="#函数声明的物种方式" class="headerlink" title="函数声明的物种方式"></a>函数声明的物种方式</h2><p>1.关键字声明一个具名函数<figure class="highlight plain"><figcaption><span>x (x,y)&#123;return x+y&#125;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.function声明一个匿名函数```var a = function (x,y)&#123;return undefined&#125;```但是必须要先声明一个变量把这个函数赋值给这个变量。```a.name = &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<p>3.使用var 声明一个变量 并赋值一个具名函数<figure class="highlight plain"><figcaption><span>x </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.window.Function()来生成，```var f = new function(&apos;x&apos;,&apos;y&apos;,&apos;return x + y&apos;)f.name = &quot;anonymous&quot;</span><br></pre></td></tr></table></figure></p>
<p>5.箭头函数,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 函数的调用</span><br><span class="line">* 函数的调用的方法有两种，f(),和f.call()。f.call()接受三个参数，第一个是this，从第二个开始才是函数接受的参数。</span><br><span class="line">* f 和f.call的区别是f指的是函数对象，f.call是用eval执行函数体。eval()是将传入的字符串当代码执行。</span><br><span class="line">* 可以执行代码就是一个函数，可以这样对函数定义。</span><br><span class="line">* f()和f.call(undefined,1,2)这两种方法可以调用函数。使用f.cals()第二个开始后面才是传的参数。</span><br><span class="line"></span><br><span class="line">## this和arguments</span><br><span class="line">* ```function z (x,y)&#123;return x + y &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>```f.call(undefined,1,,2)```这种调用中第一个参数就是this，后面的参数就是arguments。
arguments是一个伪数组，```__proto__```没有指向```Array.prototype```.
</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>函数的作用域就是这个函数内部。</li>
<li>变量提升：var和function都会被提升到头部。<code>var a =  3;</code>其实是两个语句<code>var a ;a = 3;</code>。</li>
<li><code>var a = 0; function f1(){alert(a);var a = 2};f1.call()</code>这个中alert(a)的值是udefined，因为其中var = a 会被变量提升到f1的顶部，但是此时的a并没有赋值，只是被声明了，所以执行alert(a)会是undefined。</li>
<li><code>var a  = 1 ; function f1(){var a = 2; f2.call()};function f2(){console.log(a)}</code>,这个中console.log(a)会打印出1，执行f1函数的时候里面有f2.call(),这是会执行f2,f2里面只有console.log(a),但是f2中没有声明变量a，就会在f2的上一层找，也就是a = 1,所以打印出来的是1.</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>定义就是一个函数使用它范围外的变量，那么这个函数+变量就是一个闭包。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/09/函数/" data-id="cjbviyeb10009ilol9bile4qm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS基本语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/01/JS基本语法/" class="article-date">
  <time datetime="2017-12-01T12:12:34.000Z" itemprop="datePublished">2017-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/01/JS基本语法/">JS基本语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本的语句"><a href="#基本的语句" class="headerlink" title="基本的语句"></a>基本的语句</h2><ul>
<li><p>break:终止当前的循环，使程序跳转到下一个语句执行。是跳出一个代码块或者一个循环。和label一起使用，用来跳出某个循环到某个位置。</p>
</li>
<li><p>continu:表示终止本轮的循环，立即返回循环的头部开始下一轮的循环，还在这个循环之中，进行这个循环。和label一起使用，用来跳出某个循环到某个位置。</p>
</li>
<li><p>switch():将switch的表达式和case子句相比较，如果满足就执行case语句，如果不满足就到下一个case子句中匹配。每个case语句后面都要跟一个break，以用来跳出这个case语句。</p>
</li>
<li><p>for：循环语句的另一种方式，for(var i = 0    ; i &lt;10; i++ ){}，这个例子就是申明一个初始的值，当i&lt;10的时候就执行{}里面的语句，然后i+1，直达不满足i&lt;10的条件，结束循环。</p>
</li>
<li><p>while：while(){}包括一个循环条件和一个代码块，只要条件为真，就不断执行循环的代码块，直到不满足条件时候为止。</p>
</li>
<li><p>do…….while语句，不管条件是真还是假的都要先执行一次循环，do….while语句的后面一定要加分号，这个不能够省略。</p>
</li>
</ul>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><ul>
<li>所有var声明的变量都会被提升到代码块的头部，注意的是只有var声明的变量才会被提升。</li>
</ul>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul>
<li><p>JavaScript中对变量的声明有三种方式，var声明  let声明   const声明，这三种声明的方式不同。</p>
</li>
<li><p>var声明不支持块级作用域，并且存在了变量提升。</p>
</li>
<li><p>let声明支持块级作用域，同一个区域不允许重复声明，否则会出现语法错误。存在暂存死区，let绑定不会变量提升，在变量let申明之前使用会报错，但是var不会，从代码块运行到变量的申明之间区域就是暂存死区。</p>
</li>
<li><p>const声明一个只读的常量，不能够进行修改的。</p>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>加法运算符：即可以当做加法运算，也可以当做字符串的连接符，如果运算子是对像的话就先转换成普通类型的值(也就是先执行valueof，如果还不行的话就再toString方法，如果对象是Date实例，则先执行toString方法)，如果两个运算字有一个是字符串，另一个字符串就要转换成字符串，执行字符串的连接运算，否则，就是数值的加法运算。</p>
</li>
<li><p>余数运算符：10%3 //1  ，这个例子就是余数运算的结果。正负号是由第一个运算子的正负来决定的。</p>
</li>
<li><p>数值运算符(+,-):和加法减法不同这个是一元运算，只需要一个运算子，数值运算是将任何的值都转换成数字和Number函数的效果一样。负数值运算符，是将别的类型的值转化成负数。如果加两个负运算符则和+数值运算符想过相同。</p>
</li>
<li><p>比较运算符：其中相等运算和绝对相等运算不同，相等运算在比较的时候不是一个类型的会想转化为一个类型的数据，然后在看是不是相等。绝对相等不会进行类型的转换，如果一个是字符串String，一个是数字Number，在绝对相等的情况下就是false。其他的相等运算符如果是字符串的话就按照Unicode码数进行比较，如果不是的话，否则就先转化为数字Number().还有一个比较特殊的情况，任何的值和NaN比较返回的都是false。</p>
</li>
<li><p>且运算符：&amp;&amp;表示如果第一个运算子的布尔值位true，则返回第二个运算子的值。如果第一个运算子的布尔值位false，则直接返回第一个运算子的值，且不再对第二个运算子求值。这种跳过第二个运算子的机制，被称为『短路』。可以用来取代if结构。</p>
</li>
<li><p>或运算符：||的运算规则是如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值。如果第一个运算子的布尔值位false，则返回第二个运算子。短路对这个运算符也适用。</p>
</li>
<li><p>三元运算符： ？：分隔三个表达式，运算规则是，如果第一个表达式的布尔值位true，则返回第二个表达式的值，否则返回第三个表达式的值。</p>
</li>
</ul>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li><p>或运算|，表示两个二进制位中只要有一个为1就返回1，否则返回0。与运算&amp;，两个二进制位中只要有一个为0，就返回0，否则返回1。位运算只对整数有效，遇到小数会自动把小数部分舍去，保留整数部分。</p>
</li>
<li><p>否运算~，简单记忆就是取反值减1。对一个小数连续两次去翻运算，就可以达到取整的效果。</p>
</li>
<li><p>异或运算 0 ^ 3 //3；两个二进制位不同时返回1，相同时返回0。特殊的用法是，连续对两个数a和b进行三次异或运算，可以互换它们的值，在不引入新的变量的情况下。</p>
</li>
<li><p>左移运算符，表示将一个二进制值向左移动指定的位数，尾部补上0，即乘以2的指定次方。(最高位符号位不参与移动。)如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。</p>
</li>
<li><p>右移运算&gt;&gt;,表示将一个数的二进制向右移动指定的位数，头部补0，也就是除以指定次方。右移运算可以模拟2的整除运算。</p>
</li>
<li><p>void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。这个运算符主要使用于书签工具，以及用于在超级链接中插入代码，目的是返回undefined可以防止网页跳转。</p>
</li>
<li><p>圆括号的优先级别是最高的，可以用来提高运算的优先级。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/01/JS基本语法/" data-id="cjbviyeb4000cilolrpdfz91c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/27/JS中的对象/" class="article-date">
  <time datetime="2017-11-27T03:08:53.000Z" itemprop="datePublished">2017-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/27/JS中的对象/">JS中的对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><ul>
<li>全局对象，标准上交做global，浏览器上交做window，window属性分为两种<ul>
<li>一种是ECMAScript规定的:<br>  1.parseInt<br>  2.parseFloat<br>  3.Number()<br>  4.String()<br>  5.Boolean()<br>  6.Object()</li>
<li>一种是浏览器自己私有的:<br>  1.alert()浏览器弹窗<br>  2.promt()用户填写<br>  3.confirm()确认<br>  4.console开发者<br>  5.document()文档 DOM<br>  6.history   浏览器BOM</li>
</ul>
</li>
</ul>
<h2 id="简单类型和全局函数的区别"><a href="#简单类型和全局函数的区别" class="headerlink" title="简单类型和全局函数的区别"></a>简单类型和全局函数的区别</h2><ul>
<li>使用全局函数可以构建一个hash，可以使用API，而简单类型使用API则需要在使用的时候在内存中创建一个临时的对象，这个临时的对象在使用完以后就会被删除掉。</li>
</ul>
<h2 id="公用的属性-原型"><a href="#公用的属性-原型" class="headerlink" title="公用的属性(原型)"></a>公用的属性(原型)</h2><ul>
<li>在JS中一些公用的属性都被放在一个对象中，而需要使用的时候用<strong>proto</strong>来引用。</li>
<li>protype和<strong>proto</strong>的区别在于prototype你不写代码的时候就有的了，是对API的应用；而<strong>proto</strong>是你写代码的时候对API引用的时候所使用的。一个<strong>proto</strong>对应一个prototype.</li>
<li>var 对象  = new 函数 ；对象<strong>proto</strong> === 函数 prototype；<br>Format: <img src="https://video.jirengu.com/FpdIr-6MZgJd_S0HZCmhGhmmCtwN" alt="Alt Text"></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/27/JS中的对象/" data-id="cjbviyeay0005ilolcpb6g117" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/JS中的数据/" class="article-date">
  <time datetime="2017-11-26T12:54:30.000Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/JS中的数据/">JS中的数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS的发展历史"><a href="#JS的发展历史" class="headerlink" title="JS的发展历史"></a>JS的发展历史</h1><p>1.1991年，李爵士发明了www<br>2.1992年，李爵士的同事发明了CSS。<br>3.1994年，成立了W3C（万维网联盟）<br>4.19995年，网景公司开发了一款浏览器为Netscape-Navgator，这款浏览器的特点是支持脚本，也就是最初的JavaScript。</p>
<ul>
<li>JavaScript是由Brendan Eich（JS之父）在1995年开发出来的，当时设计这门脚本语言只花了十天的时间。JavaScript最初的名字是Mocha，后来改名为LiveScript，最后才改名为JavaScript。</li>
<li>在JavaScript被发明后，欧洲计算机制造协会发布了Unicode和UTF-8，后来网景开源了自身的浏览器，也就是现在的firfox，并像ECMA申报JavaScript标准，就是现在的ECMAScript。</li>
<li>在2004年的时候Gmail开发了一款网页上的程序，这个时候JavaScript才被正式的被称为一门编程语言，以前都是作为脚本的。</li>
<li>但是在JS被发明出来的时候也就是ECMAScript3的时候有很明显的缺点，没有模块化，内置代码少，经过这么长时间的恒更行，现在已经到了ECMAScript7了。</li>
</ul>
<h1 id="JS中的数据类型"><a href="#JS中的数据类型" class="headerlink" title="JS中的数据类型"></a>JS中的数据类型</h1><ul>
<li>在JavaScript中确定一个值是哪一种类型的时候，可以用三种方式来确定的。typeof运算符、instanceof运算符和Object.prototype.toString这三种方法。</li>
<li>typeof null //object ;typeof function()  //fucntion<h2 id="number-数字"><a href="#number-数字" class="headerlink" title="number(数字)"></a>number(数字)</h2></li>
<li>number中表示数字的方式有四种，十进制，二进制（0b开头的数字），八进制（0开头的数字，并且只有1-7的数），六进制（0x开头的表示方式）。</li>
<li>NaN也是一种特殊的数字，类型还是number， </li>
</ul>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><ul>
<li>‘你好’或者”你好”都是字符串，用单引号或者双引号将字符引起来的就是字符串。</li>
<li>’‘或者“”这种叫做空字符串，长度为0.</li>
<li>’ ‘或者“ ”这种引号中间有空格的叫做空格字符串，长度为1.</li>
<li>转义符为（\）\n表示回车，\t表示制表符（Tab），’\‘表示\（反斜杠），</li>
<li>多行字符串的书写最好中间使用+书写：<br>  var  s = ‘12345’+                                                                                          ‘5689’<br>var s = ‘123456<br>67890’这中写法中间加回车一共11个字符 长度length为11.<ul>
<li>JavaScript使用Unicode字符集，也就是说，在JavaScript引擎内部，所有的字符都用Unicode表示。并且还允许直接在程序中使用Unicode编号表示字符，就是将字符写成\uxxxx的形式，其中xxxx表示该字符的Unicode编码。</li>
<li>Base64是一种编码方式，可以将任意字符转成可打印的字符，btoa（）：字符串或者二进制转为Base64编码。atob（）：Base64编码转为原来的编码。如果要将ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。</li>
</ul>
</li>
</ul>
<h2 id="Boolean（布尔值）"><a href="#Boolean（布尔值）" class="headerlink" title="Boolean（布尔值）"></a>Boolean（布尔值）</h2><ul>
<li>布尔是一个数学家，发明了逻辑学，布尔值只有两个值true和false。</li>
<li>&amp;&amp;(and)运算符，a&amp;&amp;b只有当a和b同时为真的时候才为真，</li>
<li>||（or）运算符，a||b，当a和b两个只要有一个为真的时候都为真，只有两个都是假的时候才为假。</li>
</ul>
<h2 id="null（无）和undefined（无）"><a href="#null（无）和undefined（无）" class="headerlink" title="null（无）和undefined（无）"></a>null（无）和undefined（无）</h2><ul>
<li>null是一个数据类型，只有一个值null。</li>
<li>undefined是一个数据类型，只有一个值undefined。</li>
<li>null和undefined都是表示什么都没有，但是他们也有区别之处：1.当一个变量没有赋值的时候他的值就是undefined。（语法）2.当一个对象object不想赋值的时候，推荐的值就是null，但是也可以为undefined，通常都是null，这是惯例。</li>
</ul>
<h2 id="object（对象）"><a href="#object（对象）" class="headerlink" title="object（对象）"></a>object（对象）</h2><ul>
<li>对象也是哈希，是由简单类型number、string、null、undefined、symbol、boolean这六中简单的数据类型组成的复杂类型。由｛开始而且由｝结束。</li>
<li>函数function(){}和数组[],都是属于对象。</li>
<li>对象的生成有三种方式，var o1 = {}直接用｛｝生成，var o1 = nwe Object()用new命令生成一个Object对象，或者使用Object.create方法生成　var o1 = Object,create(Object.prototype)。</li>
<li>对象所有的键名都是字符串，加不加引号都可以，如果是数字则会自动被转为字符串，如果键名不符合标识符名的条件必须加引号的。</li>
<li>对象采用大括号｛｝表示，如果行首是一个大括号，则会一律解释为语句，如果要解释为表达式（对象）的话，必须要加（｛｝）圆括号。</li>
<li>属性的读取，var 0 = {p: ‘hello’}  o[‘p’]来读取ｐ对应的值。如果对象中的key符合标识符的规范，则可以改写成o.p这种点的运算符。</li>
<li>对象中属性的删除delete o[‘p’]那么在ｏ中，o.p为undefined,’p’ in o 为false。如果o[‘p’] = undefined;那么o.p为undefined,p in o则是true.这两种删除是有区别的。</li>
<li>查看一个对象的所有的属性，使用Object.keys方法</li>
<li>for……in循环用来遍历一个队对象的属性和值，它遍历的是对象所有可遍历的属性，会跳过不可遍历的属性，不仅遍历自身的属性，还遍历继承的属性。</li>
</ul>
<h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><ul>
<li>使用tostring转换成字符串时候，null和undefined不能够转换，number和boolean可以转换成字符串，『要注意的是如果数字1.toString()会报错的原因是因为JS引擎会将1.看成一个数字，后面的toString（）就是错误的，要想正确的书写需要(1).toString()或者1..toString()』，但是object只能转换成[object,Object]；使用＋’’的方式都能够转换成字符串，但是object还是[object,Object].使用String()全局函数和使用＋’‘的作用一样的。</li>
<li>将别的类型的数据转换成boolean，可以使用全局函数String(),也可以使用!!两次取反来进行转换，这种简单方法是老鸟的操作。其中０、NaN、’’、null、undefined这五个值的的boolean都是false。object所有boolean都是true.</li>
<li>将字符串’1’转换成number1的方法：Number(‘1’)全局函数、parseInt(‘1’,10)这种转换方式的话不能够转换小数或者说浮点数，如果是小数的话就只会转换小数前的整数值，如果转换的字符串的值大于后面的进制数，就不会转换，返回转换完的值、parseFloat(‘1.23’)既能够转化为整数，又能够转换位浮点数、－０（减零），＋（取正）。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul>
<li>如果一个对象没有被引用，它就是一个垃圾，没有任何价值，会被回收，将占用的内存返还给浏览器。</li>
</ul>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ul>
<li>深拷贝就是连个变量的改变其中一个不影响另外一个的值，之间互不影响买就是深拷贝，基本的数据类型都是深拷贝，浅拷贝就是改变一个的值会改变另一个的值。以后说深拷贝都是在object中说的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/26/JS中的数据/" data-id="cjbviyeb4000dilolfacqwj2z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/30/HTTP/">HTTP</a>
          </li>
        
          <li>
            <a href="/2017/12/22/jQuery-1/">jQuery</a>
          </li>
        
          <li>
            <a href="/2017/12/18/jQuery/">jQuery</a>
          </li>
        
          <li>
            <a href="/2017/12/14/DOM/">DOM</a>
          </li>
        
          <li>
            <a href="/2017/12/11/Array/">Array</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 张科家<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>