<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>charity</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="charity">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="charity">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="charity">
  
    <link rel="alternate" href="/atom.xml" title="charity" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">charity</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-jQuery-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/22/jQuery-1/" class="article-date">
  <time datetime="2017-12-22T09:24:15.000Z" itemprop="datePublished">2017-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/22/jQuery-1/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="jQuery和DOM之间的转换"><a href="#jQuery和DOM之间的转换" class="headerlink" title="jQuery和DOM之间的转换"></a>jQuery和DOM之间的转换</h2><ul>
<li>DOM对象和jQuery之间的转换，DOM对象可以通过jQuery进行包装成jQuery对象，$()，就可以将DOM对象包装成jQuery对象的了。jQuery对象通过[index]的方式可以将jQuery对象抓换位DOM对象。$(div)[0]=div,可以这样进行转换。</li>
<li>全局变量尽量少用，尽量使用局部变量。声明一个函数立即执行，function f(){}.call()，这样可以，局部变量的作用域只是在函数的内部，在函数 外面就不能访问到函数里面的变量。但是创建了一个函数并且立即执行这样浏览器会报错的，在function前面加一些符号就可以避免这个错误的了，还可以使用的是，{let a=1}用一个代码块，使用<code>let</code>来声明一个变量。在这个代码块外面如果没有声明a，console.log(a)会打印出undefined。</li>
</ul>
<h2 id="轮播的思路"><a href="#轮播的思路" class="headerlink" title="轮播的思路"></a>轮播的思路</h2><ul>
<li><p>让所有的轮播图在一行里面，轮播图窗口的大小就是一张图片的大小，在窗口之外的图片使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 使用jQuery获取到所有的元素，找到所有点击的图标的下标，每个看每个移动的距离乘以得到的下标就是每个图片所需要移动的距离。</span><br><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure></p>
<p>var buttons = $(‘#button &gt; span’)<br>var n = 0;<br>//.eq意思是找出对应的DOM对象，并封装成一个jQuery对象。<br>buttons.eq(n % 3).trigger(‘click’).addClass(‘red’)</p>
<pre><code>.siblings(&apos;.red&apos;).removeClass(&apos;red&apos;)
</code></pre></li>
</ul>
<p>  var timerId = setInterval(() =&gt; {<br>      n += 1<br>      buttons.eq(n % 3).trigger(‘click’).addClass(‘red’)<br>          .siblings(‘.red’).removeClass(‘red’)<br>  }, 1000)</p>
<p>  $(‘.screen’).on(‘mouseenter’, function () {<br>      window.clearInterval(timerId)<br>  })<br>  $(‘.screen’).on(‘mouseleave’, function () {<br>      timerId = setInterval(() =&gt; {<br>          n += 1<br>          buttons.eq(n % 3).trigger(‘click’).addClass(‘red’)<br>              .siblings(‘.red’).removeClass(‘red’)<br>      }, 1000)<br>  })<br>  ```</p>
<ul>
<li>设定一个美国一秒钟就可以是下一个span元素自动点击，使</li>
</ul>
<h2 id="写代码的原则"><a href="#写代码的原则" class="headerlink" title="写代码的原则"></a>写代码的原则</h2><ul>
<li>JS内容、样式、行为的分离。其中HTML负责内容，CSS负责样式，JavaScript负责行为，这是写代码的原则。但是原则有时候也可以打破的，不是一定必须要这么坚持的原则，但是坚持原则也是比较好的一种行为的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/22/jQuery-1/" data-id="cjbi2n1yf00085nolhfga2bye" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/18/jQuery/" class="article-date">
  <time datetime="2017-12-18T04:45:55.000Z" itemprop="datePublished">2017-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/18/jQuery/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自己实现一个jQuery的思路和代码"><a href="#自己实现一个jQuery的思路和代码" class="headerlink" title="自己实现一个jQuery的思路和代码"></a>自己实现一个jQuery的思路和代码</h2><ul>
<li>自己实现一个API的思路和代码</li>
</ul>
<ul>
<li><p>1.包装两个函数，添加一个className和获取一个文本内容</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function addClass(node,className)&#123;  className.forEach((value)=&gt;node.classList.add(value))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function text(node)&#123;</span><br><span class="line"></span><br><span class="line">  return text =node.innerText</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addClass(iterm1,[1,2,3])</span><br><span class="line"></span><br><span class="line">console.log(text(iterm3))</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>2.给函数起一个名字，可以用命名空间来取windon.zkjDOM={};zkjDOM.addClass=addClass;zkjDOM.text=text;有可能别人也起了一个这样的函数名字，就把别人的函数给覆盖了；还可以直接将函数添加到Node.prototype中去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Node.prototype.addClass = function (node,className)&#123;  className.forEach((value)=&gt;node.classList.add(value))&#125;,还可以新建一个Node，window.Node2 =function(node)&#123;return addClass:&#123;&#125;,text:&#123;&#125;&#125;,</span><br><span class="line">  window.Node2 = function(node)&#123;</span><br><span class="line">    return&#123;addClass: function(className)&#123;className.forEach((value) =&gt; node.classList.add(value))&#125;,</span><br><span class="line">  getText : function()&#123;return text = node.textContent&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用字符串去查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">window.Node2 = function(nodeorSelector)&#123;</span><br><span class="line"></span><br><span class="line">let node</span><br><span class="line"></span><br><span class="line">  if(typeof nodeorSelector===&apos;string&apos;)&#123;</span><br><span class="line"></span><br><span class="line">node = document.querySelector(nodeorSelector)</span><br><span class="line"></span><br><span class="line">  &#125;else if(nodeorSelector instanceof Node)&#123;</span><br><span class="line"></span><br><span class="line">node =nodeSelector&#125;</span><br><span class="line"></span><br><span class="line">return&#123;</span><br><span class="line"></span><br><span class="line">addClass: function(className)&#123;</span><br><span class="line"></span><br><span class="line">className.forEach((value) =&gt; node.classList.add(value))</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getText : function()&#123;return text = node.textContent</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var node2 = Node2(&quot;#iterm2&quot;)</span><br><span class="line"></span><br><span class="line">node2.addClass([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])</span><br><span class="line"></span><br><span class="line">console.log(node2.getText())</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><p>可以查找多个并：</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- window.jQuery = function(nodeorSelector)&#123;</span><br><span class="line">  let nodes=&#123;&#125;</span><br><span class="line">  if(typeof nodeorSelector===&apos;string&apos;)&#123;</span><br><span class="line">  let temp = document.querySelectorAll(nodeorSelector)</span><br><span class="line">  for(let i= 0;i&lt;temp.length;i++)&#123;</span><br><span class="line">  nodes[i]=temp[i]</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.length = temp.length</span><br><span class="line">  &#125;else if(nodeorSelector instanceof Node)&#123;</span><br><span class="line">  node =&#123;0:nodeorSelector,length:1&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = function(className)&#123;className.forEach((value) =&gt; &#123;</span><br><span class="line">  for(let i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">  nodes[i].classList.add(value)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.getText =function()&#123;</span><br><span class="line">  let texts =[]</span><br><span class="line">  for(let i=0;i&lt; nodes.length;i++)&#123;</span><br><span class="line">  texts.push(nodes[i].innerText)</span><br><span class="line">  &#125;</span><br><span class="line">  return texts</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText =function(text)&#123;</span><br><span class="line">  for(i=0;i &lt; nodes.length;i++)&#123;</span><br><span class="line">  nodes[i].innerText = text</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  return nodes</span><br><span class="line">  &#125;</span><br><span class="line">  var node2 = jQuery(&quot;div&quot;)</span><br><span class="line">  console.log(node2)</span><br><span class="line">  node2.addClass([&apos;a&apos;])</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/18/jQuery/" data-id="cjbi2n1yf00095nol331bvh0b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/14/DOM/" class="article-date">
  <time datetime="2017-12-14T11:40:50.000Z" itemprop="datePublished">2017-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/14/DOM/">DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li><p>DOM是JavaScript操作网页的接口，全称为Document Object Model，也就是文档对象模型，它的作用试讲网页转为一个JavaScript对象，从而可以用脚本进行各种操作。浏览器会根据DOM模型，将结构化文档解析成一系列的节点，再由这些节点组成一个树状结构，也就是DOM tree。</p>
</li>
<li><p>节点的类型有七种类型：</p>
<p>1.Document类型整个文档树的顶层节点</p>
<p>2.DocumentType:doctype标签，比如&lt;!DOCTYPE html&gt;</p>
<p>3.Element:网页的各种HTML标签</p>
<p>4.Attribute：网页元素的属性（如class:’right’）</p>
<p>5.Text:标签之间或标签包含的文本</p>
<p>6.Comment:注释</p>
<p>7.DocumentFragment:文档的片段</p>
</li>
<li><p>DOM的最小组成单位是节点node。最顶层的节点就是document节点，它代表了整个文档。文档里面的最高一层的HTML标签，一班是<code>&lt;html&gt;</code>，它构成了树结构的根节点（root node），其他HTML标签节点都是它的下级。</p>
</li>
<li><p>页面中的节点通过构造函数构造出对应的对象，这就是DOM的主要功能。</p>
</li>
<li><p>Node的属性</p>
<p>1.childNodes表示所有的子节点</p>
<p>2.nodeName返回的都是字符串，除了svg以外，所有的都是大写的返回值。</p>
<p>3.获取html要使用<code>document.document.element</code>,</p>
<p>4.nodeType，值是1的时候表示的是element，值是3的时候表示的是Text，值是9的时候表示document。</p>
<p>5.innertext只会获取文本，而textContent除了获取文本以外还会获取script和style元素。</p>
<p>6.cloneNode表示克隆节点，后面接受一个参数表示是否接受深拷贝。true表示接受，false表示不接受深拷贝。</p>
<p>7.isEqualNode表示相等的两个节点，isSameNode表示相同的两个节点，可以理解位就是同一个节点才会是相同的。</p>
<p>8.removeChild表示移除子节点，但是还是会在内存中，可以被调用的。</p>
</li>
<li><p>Docucment接口：</p>
<p>1.body获取body元素</p>
<p>2.characterSet获取字符编码</p>
<p>3.documentElement获取的就是html元素，是文档的根元素。</p>
<p>4.document.domain获取你的域名</p>
<p>5.document.links获取页面中所有的a标签。</p>
<p>6.document.plugins获取是否装了插件</p>
<p>7.referrer引荐人</p>
<p>8.visibilityStates表示页面是否可以显示</p>
<p>9.document.execCommand（）表示执行命令</p>
<p>10.document.qurySelector()返回一个元素，但是document.querySelectorAll()返回的是一个伪数组，不管里面的有几个都是一个伪数组，原型指向的是NodeLise.prototype</p>
</li>
<li><p>element接口</p>
<p>1.attribute返回一个和该元素相关的所有属性的集合</p>
<p>2.accessKey设置一个按键，用户桶过敲击这个按键吧焦点跳转到这个元素上。</p>
<p>3.clientLeft表示一个元素左边框的宽度</p>
<p>4.clientTop获取一个元素顶部的距离</p>
<p>5.innerHTML和textContent的区别是textContent只获取到文本，innerHTML是可以获取到里面的标签。</p>
<p>6.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/14/DOM/" data-id="cjbi2n1y900015nolrbvnt7sz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/11/Array/" class="article-date">
  <time datetime="2017-12-11T05:26:10.000Z" itemprop="datePublished">2017-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/11/Array/">Array</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ul>
<li>数组就是一组有序集合，在JS中的数组就是原型链中有Array.prototype的对象。数组恩每个值都有自己对应的编号(从0开始)，整个数组用方括号表示。</li>
<li>生成数组的方式有两种：一种是直接用[]来生成，第二种是使用new Array来生成数组，这两种方法生成的。其中使用new Array和使用Array来生成数组是一样的。</li>
<li>有一点是要注意的，当使用Array构造汗数来生成数组的时候，当你传入的参数位一个的时候，这个时候你只能生成一个length为传入参数的空数组，每一项的值都是undefined。当你传入的参数多于一个的时候生成的数组的值就是你穿如的参数，数组的length就是你穿如参数的个数。</li>
<li>![Alt  text][./数组.png]</li>
</ul>
<h3 id="函数声明的方式"><a href="#函数声明的方式" class="headerlink" title="函数声明的方式"></a>函数声明的方式</h3><p>1.具名函数</p>
<figure class="highlight plain"><figcaption><span>f (x,y)&#123;return x + y&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.匿名函数加var</p>
<figure class="highlight plain"><figcaption><span>f ; f </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.具名函数加var </p>
<figure class="highlight plain"><figcaption><span>f1 ; f1 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.window.Function +var </p>
<figure class="highlight plain"><figcaption><span>f ; f </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.箭头函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h2><ul>
<li>什么是伪数组：就是有0，1，2，3，4，5…..n，length这些key的对象，但是原型链中没有Array.prototype。目前直到的伪数组有arguments对象，和document.querySelectAll返回的对象。</li>
</ul>
<h2 id="数组中的API"><a href="#数组中的API" class="headerlink" title="数组中的API"></a>数组中的API</h2><ul>
<li>Array.peototype.forEach,后面接一个函数，表示对数组中的每一个元素执行一次所对应的函数。</li>
<li>Array,prototype.Sort后面接一个函数，函数接受两个参数，分别是数组中的两个值，返回值位两个值的差。如果大于0 则按照从小到大的顺序对数组进行排列，如果小于0的话，则按照从大到小的顺序排列。</li>
<li>Array.prototype.join用于将一个数组的所有元素连接到一个字符串中，返回值是一个字符串。</li>
<li>Array.prototype.Concat用于节哀那个两个数组合并为一个数组，返回一个新的数组，但不会更改现有的数组。</li>
<li>Array.prototype.toString用于将一个数组转为字符串</li>
<li>Array.prototype.map用于创建一个新数组，七街狗是该数组中的每一个元素都调用一个提供的函数后返回的结果。</li>
<li>Array.prototype.filter后面接一个函数，用来将一个数组特定的值过滤出来。</li>
<li>Array.prototype.reduce后面接一个函数，接两个参数，第一个是前面累加的值，第二个是正咋处理的元素，这个API的用法就是用来求和的，你可以将这个想象成抢劫的应用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/11/Array/" data-id="cjbi2n1y000005nolzx0k7t51" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/10/对象/" class="article-date">
  <time datetime="2017-12-10T04:25:56.000Z" itemprop="datePublished">2017-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/10/对象/">JS中的对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS中的对象"><a href="#JS中的对象" class="headerlink" title="JS中的对象"></a>JS中的对象</h1><h2 id="什么是全局对象和全局变量"><a href="#什么是全局对象和全局变量" class="headerlink" title="什么是全局对象和全局变量"></a>什么是全局对象和全局变量</h2><ul>
<li><p>ECMAScript中规定全局对象是global，但是在浏览器中全局对象是window，不管你在哪个网页一定可以访问到一个对象，就是window。window是一个hash表，有很多属性，这些属性就是全局对象。</p>
</li>
<li><p>window中的属性包含两种，一种是ECMAScript规定的，不管是在Node.js还是在浏览器中都要有这些属性；另一种则是浏览器私有的，就是在某些浏览器中才有的一些属性。每个浏览器的私有属性的标准都是不一样的，因为没有标准的规定，所以不一样。</p>
<p>1.ECMAScript规定的</p>
<ul>
<li>global.parseInt      (将字符串转为数字，接受两个参数，第一个是要转换的字符串，第二是转换的进制数)</li>
</ul>
</li>
</ul>
<ul>
<li>global.parseFloat    (将字符串转为浮点数)</li>
</ul>
<ul>
<li>global.Number    (将别的类型的值转为Number  数字)</li>
<li>Global.String    (将别的类型的值转为String 字符串)</li>
<li>global.Boolean   (将别的类型的值转为Boolean 布尔值)</li>
<li><p>global.Object    (将别的类型的值转为Object 对象)</p>
<p>2.浏览器自己加的属性</p>
</li>
</ul>
<ul>
<li>window.alert   (弹框提示)</li>
<li>window.promt  (让用户填东西)</li>
<li>window.confirm  (让用户确认)</li>
<li>window.console.log   (让开发者打印东西)</li>
<li>window.console.dir  (打印出对象所有的属性)</li>
<li>window.document (也有自己的规范也就是DOM，是由W3C指定的规范)</li>
<li>window.document.createElement (再文档中创建新的元素)</li>
<li>window.docuemnt.getElementById   (获取文档中有这个id的元素)</li>
</ul>
<h2 id="JS中简单类型和对象的区别"><a href="#JS中简单类型和对象的区别" class="headerlink" title="JS中简单类型和对象的区别"></a>JS中简单类型和对象的区别</h2><ul>
<li><p>Number的用法有两种：</p>
<p>1.将一个字符串”1”转换位数字1</p>
<p>2.作为一个构造函数创建一个对象1，<code>var n = new Number(1)</code></p>
</li>
<li><p>简单类型的1和对象的的区别是在内存中,简单类型的1是直接存在stack内存中的，而对象1在stack中存了这个对象地址，而对象是存在heap内存中的，，这个对象其实是一个hash，包含了Number对象的各种属性，这个对象1要调用对象中的属性时，就通过stack中的地址找到heap中的对象，使用对象中的属性。那么简单类型的1为什么也可以使用Number中的属性呢？原因就是在简单类型1使用Number的方法的时候，会将简单类型1封装成一个临时对象，然后再调用Number对象中的属性。这个临时的对象在使用完成以后会被删除回收掉。</p>
</li>
<li><p>String的用法也是有两种：</p>
<p>1.将一个别的类型的值转为字符串</p>
<p>2.作为构造函数，创建一个字符串对象 <code>var s = new String(&#39;sdkkhfkdljfk&#39;)</code>;这个对象中有很多的属性，<code>s.charAt(1) =d</code>获取某一个索引对应的字符，s.<code>charCodeAt(0)=115</code>,获取某个索引对应字符的Unicode编码的数字，<code>(100).toString(16) = 64</code>表示将数字100转为16进制位64。<code>trim(),&#39;   username  &#39;.trim();返回值为&quot;username&quot;去掉字符串中的空格</code>，<code>concat()连接两个字符串，var s= &#39;hello&#39;; var s1 = &#39;world&#39;; s.concat(s1)=&#39;hello world&#39;</code>,<code>var a = &#39;hello&#39;; a.slice(0,3)返回&quot;hel&quot;</code>,<code>var a = &#39;hello&#39;;e.replace(&#39;o&#39;);返回&quot;hollo&quot;</code>。</p>
</li>
<li><p>Boolean的用法也是两种：</p>
<p>1.将别的类型转为布尔值，其中五个falsy值，”0”、”AaN”、””(空字符串)、”null”、”undefined”;</p>
<p>2.作为构造函数，穿件一个对象，所有的对象都是true,</p>
</li>
<li><p>Object:就是创建一个函数。</p>
</li>
</ul>
<h2 id="共有属性"><a href="#共有属性" class="headerlink" title="共有属性"></a>共有属性</h2><ul>
<li>String.prototype是String的公有属性的引用，如果没有就不能引用String的共有属性，会被垃圾回收，而<code>s.__proto__</code>是为了要使用String的公有属性，如果没有<code>__proto__</code>就不能够引用String的共有属性。</li>
<li><img src="/Users/kejia/Desktop/JS中的对象.png" alt="JS中的对象"></li>
<li>​</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/10/对象/" data-id="cjbi2n1yg000a5nol4juuxm1z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/09/函数/" class="article-date">
  <time datetime="2017-12-09T08:05:28.000Z" itemprop="datePublished">2017-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/09/函数/">函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数声明的物种方式"><a href="#函数声明的物种方式" class="headerlink" title="函数声明的物种方式"></a>函数声明的物种方式</h2><p>1.关键字声明一个具名函数<figure class="highlight plain"><figcaption><span>x (x,y)&#123;return x+y&#125;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.function声明一个匿名函数```var a = function (x,y)&#123;return undefined&#125;```但是必须要先声明一个变量把这个函数赋值给这个变量。```a.name = &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<p>3.使用var 声明一个变量 并赋值一个具名函数<figure class="highlight plain"><figcaption><span>x </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.window.Function()来生成，```var f = new function(&apos;x&apos;,&apos;y&apos;,&apos;return x + y&apos;)f.name = &quot;anonymous&quot;</span><br></pre></td></tr></table></figure></p>
<p>5.箭头函数,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 函数的调用</span><br><span class="line">* 函数的调用的方法有两种，f(),和f.call()。f.call()接受三个参数，第一个是this，从第二个开始才是函数接受的参数。</span><br><span class="line">* f 和f.call的区别是f指的是函数对象，f.call是用eval执行函数体。eval()是将传入的字符串当代码执行。</span><br><span class="line">* 可以执行代码就是一个函数，可以这样对函数定义。</span><br><span class="line">* f()和f.call(undefined,1,2)这两种方法可以调用函数。使用f.cals()第二个开始后面才是传的参数。</span><br><span class="line"></span><br><span class="line">## this和arguments</span><br><span class="line">* ```function z (x,y)&#123;return x + y &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>```f.call(undefined,1,,2)```这种调用中第一个参数就是this，后面的参数就是arguments。
arguments是一个伪数组，```__proto__```没有指向```Array.prototype```.
</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>函数的作用域就是这个函数内部。</li>
<li>变量提升：var和function都会被提升到头部。<code>var a =  3;</code>其实是两个语句<code>var a ;a = 3;</code>。</li>
<li><code>var a = 0; function f1(){alert(a);var a = 2};f1.call()</code>这个中alert(a)的值是udefined，因为其中var = a 会被变量提升到f1的顶部，但是此时的a并没有赋值，只是被声明了，所以执行alert(a)会是undefined。</li>
<li><code>var a  = 1 ; function f1(){var a = 2; f2.call()};function f2(){console.log(a)}</code>,这个中console.log(a)会打印出1，执行f1函数的时候里面有f2.call(),这是会执行f2,f2里面只有console.log(a),但是f2中没有声明变量a，就会在f2的上一层找，也就是a = 1,所以打印出来的是1.</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>定义就是一个函数使用它范围外的变量，那么这个函数+变量就是一个闭包。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/09/函数/" data-id="cjbi2n1yh000b5nolyuvcisgn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS基本语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/01/JS基本语法/" class="article-date">
  <time datetime="2017-12-01T12:12:34.000Z" itemprop="datePublished">2017-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/01/JS基本语法/">JS基本语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本的语句"><a href="#基本的语句" class="headerlink" title="基本的语句"></a>基本的语句</h2><ul>
<li><p>break:终止当前的循环，使程序跳转到下一个语句执行。是跳出一个代码块或者一个循环。和label一起使用，用来跳出某个循环到某个位置。</p>
</li>
<li><p>continu:表示终止本轮的循环，立即返回循环的头部开始下一轮的循环，还在这个循环之中，进行这个循环。和label一起使用，用来跳出某个循环到某个位置。</p>
</li>
<li><p>switch():将switch的表达式和case子句相比较，如果满足就执行case语句，如果不满足就到下一个case子句中匹配。每个case语句后面都要跟一个break，以用来跳出这个case语句。</p>
</li>
<li><p>for：循环语句的另一种方式，for(var i = 0    ; i &lt;10; i++ ){}，这个例子就是申明一个初始的值，当i&lt;10的时候就执行{}里面的语句，然后i+1，直达不满足i&lt;10的条件，结束循环。</p>
</li>
<li><p>while：while(){}包括一个循环条件和一个代码块，只要条件为真，就不断执行循环的代码块，直到不满足条件时候为止。</p>
</li>
<li><p>do…….while语句，不管条件是真还是假的都要先执行一次循环，do….while语句的后面一定要加分号，这个不能够省略。</p>
</li>
</ul>
<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><ul>
<li>所有var声明的变量都会被提升到代码块的头部，注意的是只有var声明的变量才会被提升。</li>
</ul>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul>
<li><p>JavaScript中对变量的声明有三种方式，var声明  let声明   const声明，这三种声明的方式不同。</p>
</li>
<li><p>var声明不支持块级作用域，并且存在了变量提升。</p>
</li>
<li><p>let声明支持块级作用域，同一个区域不允许重复声明，否则会出现语法错误。存在暂存死区，let绑定不会变量提升，在变量let申明之前使用会报错，但是var不会，从代码块运行到变量的申明之间区域就是暂存死区。</p>
</li>
<li><p>const声明一个只读的常量，不能够进行修改的。</p>
</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li><p>加法运算符：即可以当做加法运算，也可以当做字符串的连接符，如果运算子是对像的话就先转换成普通类型的值(也就是先执行valueof，如果还不行的话就再toString方法，如果对象是Date实例，则先执行toString方法)，如果两个运算字有一个是字符串，另一个字符串就要转换成字符串，执行字符串的连接运算，否则，就是数值的加法运算。</p>
</li>
<li><p>余数运算符：10%3 //1  ，这个例子就是余数运算的结果。正负号是由第一个运算子的正负来决定的。</p>
</li>
<li><p>数值运算符(+,-):和加法减法不同这个是一元运算，只需要一个运算子，数值运算是将任何的值都转换成数字和Number函数的效果一样。负数值运算符，是将别的类型的值转化成负数。如果加两个负运算符则和+数值运算符想过相同。</p>
</li>
<li><p>比较运算符：其中相等运算和绝对相等运算不同，相等运算在比较的时候不是一个类型的会想转化为一个类型的数据，然后在看是不是相等。绝对相等不会进行类型的转换，如果一个是字符串String，一个是数字Number，在绝对相等的情况下就是false。其他的相等运算符如果是字符串的话就按照Unicode码数进行比较，如果不是的话，否则就先转化为数字Number().还有一个比较特殊的情况，任何的值和NaN比较返回的都是false。</p>
</li>
<li><p>且运算符：&amp;&amp;表示如果第一个运算子的布尔值位true，则返回第二个运算子的值。如果第一个运算子的布尔值位false，则直接返回第一个运算子的值，且不再对第二个运算子求值。这种跳过第二个运算子的机制，被称为『短路』。可以用来取代if结构。</p>
</li>
<li><p>或运算符：||的运算规则是如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值。如果第一个运算子的布尔值位false，则返回第二个运算子。短路对这个运算符也适用。</p>
</li>
<li><p>三元运算符： ？：分隔三个表达式，运算规则是，如果第一个表达式的布尔值位true，则返回第二个表达式的值，否则返回第三个表达式的值。</p>
</li>
</ul>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul>
<li><p>或运算|，表示两个二进制位中只要有一个为1就返回1，否则返回0。与运算&amp;，两个二进制位中只要有一个为0，就返回0，否则返回1。位运算只对整数有效，遇到小数会自动把小数部分舍去，保留整数部分。</p>
</li>
<li><p>否运算~，简单记忆就是取反值减1。对一个小数连续两次去翻运算，就可以达到取整的效果。</p>
</li>
<li><p>异或运算 0 ^ 3 //3；两个二进制位不同时返回1，相同时返回0。特殊的用法是，连续对两个数a和b进行三次异或运算，可以互换它们的值，在不引入新的变量的情况下。</p>
</li>
<li><p>左移运算符，表示将一个二进制值向左移动指定的位数，尾部补上0，即乘以2的指定次方。(最高位符号位不参与移动。)如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效。</p>
</li>
<li><p>右移运算&gt;&gt;,表示将一个数的二进制向右移动指定的位数，头部补0，也就是除以指定次方。右移运算可以模拟2的整除运算。</p>
</li>
<li><p>void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined。这个运算符主要使用于书签工具，以及用于在超级链接中插入代码，目的是返回undefined可以防止网页跳转。</p>
</li>
<li><p>圆括号的优先级别是最高的，可以用来提高运算的优先级。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/01/JS基本语法/" data-id="cjbi2n1yd00055nolfc4u5ylk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/27/JS中的对象/" class="article-date">
  <time datetime="2017-11-27T03:08:53.000Z" itemprop="datePublished">2017-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/27/JS中的对象/">JS中的对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h2><ul>
<li>全局对象，标准上交做global，浏览器上交做window，window属性分为两种<ul>
<li>一种是ECMAScript规定的:<br>  1.parseInt<br>  2.parseFloat<br>  3.Number()<br>  4.String()<br>  5.Boolean()<br>  6.Object()</li>
<li>一种是浏览器自己私有的:<br>  1.alert()浏览器弹窗<br>  2.promt()用户填写<br>  3.confirm()确认<br>  4.console开发者<br>  5.document()文档 DOM<br>  6.history   浏览器BOM</li>
</ul>
</li>
</ul>
<h2 id="简单类型和全局函数的区别"><a href="#简单类型和全局函数的区别" class="headerlink" title="简单类型和全局函数的区别"></a>简单类型和全局函数的区别</h2><ul>
<li>使用全局函数可以构建一个hash，可以使用API，而简单类型使用API则需要在使用的时候在内存中创建一个临时的对象，这个临时的对象在使用完以后就会被删除掉。</li>
</ul>
<h2 id="公用的属性-原型"><a href="#公用的属性-原型" class="headerlink" title="公用的属性(原型)"></a>公用的属性(原型)</h2><ul>
<li>在JS中一些公用的属性都被放在一个对象中，而需要使用的时候用<strong>proto</strong>来引用。</li>
<li>protype和<strong>proto</strong>的区别在于prototype你不写代码的时候就有的了，是对API的应用；而<strong>proto</strong>是你写代码的时候对API引用的时候所使用的。一个<strong>proto</strong>对应一个prototype.</li>
<li>var 对象  = new 函数 ；对象<strong>proto</strong> === 函数 prototype；<br>Format: <img src="https://video.jirengu.com/FpdIr-6MZgJd_S0HZCmhGhmmCtwN" alt="Alt Text"></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/27/JS中的对象/" data-id="cjbi2n1yc00045nolpimey0wz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS中的数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/26/JS中的数据/" class="article-date">
  <time datetime="2017-11-26T12:54:30.000Z" itemprop="datePublished">2017-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/26/JS中的数据/">JS中的数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS的发展历史"><a href="#JS的发展历史" class="headerlink" title="JS的发展历史"></a>JS的发展历史</h1><p>1.1991年，李爵士发明了www<br>2.1992年，李爵士的同事发明了CSS。<br>3.1994年，成立了W3C（万维网联盟）<br>4.19995年，网景公司开发了一款浏览器为Netscape-Navgator，这款浏览器的特点是支持脚本，也就是最初的JavaScript。</p>
<ul>
<li>JavaScript是由Brendan Eich（JS之父）在1995年开发出来的，当时设计这门脚本语言只花了十天的时间。JavaScript最初的名字是Mocha，后来改名为LiveScript，最后才改名为JavaScript。</li>
<li>在JavaScript被发明后，欧洲计算机制造协会发布了Unicode和UTF-8，后来网景开源了自身的浏览器，也就是现在的firfox，并像ECMA申报JavaScript标准，就是现在的ECMAScript。</li>
<li>在2004年的时候Gmail开发了一款网页上的程序，这个时候JavaScript才被正式的被称为一门编程语言，以前都是作为脚本的。</li>
<li>但是在JS被发明出来的时候也就是ECMAScript3的时候有很明显的缺点，没有模块化，内置代码少，经过这么长时间的恒更行，现在已经到了ECMAScript7了。</li>
</ul>
<h1 id="JS中的数据类型"><a href="#JS中的数据类型" class="headerlink" title="JS中的数据类型"></a>JS中的数据类型</h1><ul>
<li>在JavaScript中确定一个值是哪一种类型的时候，可以用三种方式来确定的。typeof运算符、instanceof运算符和Object.prototype.toString这三种方法。</li>
<li>typeof null //object ;typeof function()  //fucntion<h2 id="number-数字"><a href="#number-数字" class="headerlink" title="number(数字)"></a>number(数字)</h2></li>
<li>number中表示数字的方式有四种，十进制，二进制（0b开头的数字），八进制（0开头的数字，并且只有1-7的数），六进制（0x开头的表示方式）。</li>
<li>NaN也是一种特殊的数字，类型还是number， </li>
</ul>
<h2 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h2><ul>
<li>‘你好’或者”你好”都是字符串，用单引号或者双引号将字符引起来的就是字符串。</li>
<li>’‘或者“”这种叫做空字符串，长度为0.</li>
<li>’ ‘或者“ ”这种引号中间有空格的叫做空格字符串，长度为1.</li>
<li>转义符为（\）\n表示回车，\t表示制表符（Tab），’\‘表示\（反斜杠），</li>
<li>多行字符串的书写最好中间使用+书写：<br>  var  s = ‘12345’+                                                                                          ‘5689’<br>var s = ‘123456<br>67890’这中写法中间加回车一共11个字符 长度length为11.<ul>
<li>JavaScript使用Unicode字符集，也就是说，在JavaScript引擎内部，所有的字符都用Unicode表示。并且还允许直接在程序中使用Unicode编号表示字符，就是将字符写成\uxxxx的形式，其中xxxx表示该字符的Unicode编码。</li>
<li>Base64是一种编码方式，可以将任意字符转成可打印的字符，btoa（）：字符串或者二进制转为Base64编码。atob（）：Base64编码转为原来的编码。如果要将ASCII码字符转为Base64编码，必须中间插入一个转码环节，再使用这两个方法。</li>
</ul>
</li>
</ul>
<h2 id="Boolean（布尔值）"><a href="#Boolean（布尔值）" class="headerlink" title="Boolean（布尔值）"></a>Boolean（布尔值）</h2><ul>
<li>布尔是一个数学家，发明了逻辑学，布尔值只有两个值true和false。</li>
<li>&amp;&amp;(and)运算符，a&amp;&amp;b只有当a和b同时为真的时候才为真，</li>
<li>||（or）运算符，a||b，当a和b两个只要有一个为真的时候都为真，只有两个都是假的时候才为假。</li>
</ul>
<h2 id="null（无）和undefined（无）"><a href="#null（无）和undefined（无）" class="headerlink" title="null（无）和undefined（无）"></a>null（无）和undefined（无）</h2><ul>
<li>null是一个数据类型，只有一个值null。</li>
<li>undefined是一个数据类型，只有一个值undefined。</li>
<li>null和undefined都是表示什么都没有，但是他们也有区别之处：1.当一个变量没有赋值的时候他的值就是undefined。（语法）2.当一个对象object不想赋值的时候，推荐的值就是null，但是也可以为undefined，通常都是null，这是惯例。</li>
</ul>
<h2 id="object（对象）"><a href="#object（对象）" class="headerlink" title="object（对象）"></a>object（对象）</h2><ul>
<li>对象也是哈希，是由简单类型number、string、null、undefined、symbol、boolean这六中简单的数据类型组成的复杂类型。由｛开始而且由｝结束。</li>
<li>函数function(){}和数组[],都是属于对象。</li>
<li>对象的生成有三种方式，var o1 = {}直接用｛｝生成，var o1 = nwe Object()用new命令生成一个Object对象，或者使用Object.create方法生成　var o1 = Object,create(Object.prototype)。</li>
<li>对象所有的键名都是字符串，加不加引号都可以，如果是数字则会自动被转为字符串，如果键名不符合标识符名的条件必须加引号的。</li>
<li>对象采用大括号｛｝表示，如果行首是一个大括号，则会一律解释为语句，如果要解释为表达式（对象）的话，必须要加（｛｝）圆括号。</li>
<li>属性的读取，var 0 = {p: ‘hello’}  o[‘p’]来读取ｐ对应的值。如果对象中的key符合标识符的规范，则可以改写成o.p这种点的运算符。</li>
<li>对象中属性的删除delete o[‘p’]那么在ｏ中，o.p为undefined,’p’ in o 为false。如果o[‘p’] = undefined;那么o.p为undefined,p in o则是true.这两种删除是有区别的。</li>
<li>查看一个对象的所有的属性，使用Object.keys方法</li>
<li>for……in循环用来遍历一个队对象的属性和值，它遍历的是对象所有可遍历的属性，会跳过不可遍历的属性，不仅遍历自身的属性，还遍历继承的属性。</li>
</ul>
<h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><ul>
<li>使用tostring转换成字符串时候，null和undefined不能够转换，number和boolean可以转换成字符串，『要注意的是如果数字1.toString()会报错的原因是因为JS引擎会将1.看成一个数字，后面的toString（）就是错误的，要想正确的书写需要(1).toString()或者1..toString()』，但是object只能转换成[object,Object]；使用＋’’的方式都能够转换成字符串，但是object还是[object,Object].使用String()全局函数和使用＋’‘的作用一样的。</li>
<li>将别的类型的数据转换成boolean，可以使用全局函数String(),也可以使用!!两次取反来进行转换，这种简单方法是老鸟的操作。其中０、NaN、’’、null、undefined这五个值的的boolean都是false。object所有boolean都是true.</li>
<li>将字符串’1’转换成number1的方法：Number(‘1’)全局函数、parseInt(‘1’,10)这种转换方式的话不能够转换小数或者说浮点数，如果是小数的话就只会转换小数前的整数值，如果转换的字符串的值大于后面的进制数，就不会转换，返回转换完的值、parseFloat(‘1.23’)既能够转化为整数，又能够转换位浮点数、－０（减零），＋（取正）。</li>
</ul>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ul>
<li>如果一个对象没有被引用，它就是一个垃圾，没有任何价值，会被回收，将占用的内存返还给浏览器。</li>
</ul>
<h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><ul>
<li>深拷贝就是连个变量的改变其中一个不影响另外一个的值，之间互不影响买就是深拷贝，基本的数据类型都是深拷贝，浅拷贝就是改变一个的值会改变另一个的值。以后说深拷贝都是在object中说的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/26/JS中的数据/" data-id="cjbi2n1z6000c5nolca9zz15a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTML" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/25/HTML/" class="article-date">
  <time datetime="2017-11-25T02:59:53.000Z" itemprop="datePublished">2017-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/25/HTML/">HTML</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTML总结复习"><a href="#HTML总结复习" class="headerlink" title="HTML总结复习"></a>HTML总结复习</h1><pre><code>以前学习的了忘记了没有总结的觉得重要的现在重新写一篇博客来增加记忆，以便以后用来复习。温故而知新！
</code></pre><h2 id="表单元素form"><a href="#表单元素form" class="headerlink" title="表单元素form"></a>表单元素form</h2><ul>
<li>action：属性值指定了表单提交到服务器的地址。</li>
<li>target：规定了在何处打开action的URL，和a标签的target一样有四个值，_blank(新窗口)、_self（本窗口）、_parent（父窗口）、_top(顶层窗口)。</li>
<li>method：规定了用来发送表单数据的HTTP方法，post 或者get。</li>
<li>accept：服务器接受的文件类型。</li>
<li>表单中插入一个多行文本框textarea   ；语法&lt;textarea form=”form_id” textarea的form要是form的id选择器。</li>
</ul>
<pre><code>### input 自闭和标签
    * type：button（可点击的按钮）、checkbox（复选框）、file(上传文件或者图片。)、password(输入密码)输入的字符会以点的形式出现、radio(单选框)input的name值要是一样的不然不能实现单选的要求、search(单行的搜索文本)、reset(重置所有的表单信息)、submit(提交)、email(用于e-mail地址的字段)当你的email格式不对事会提醒并不能提交表单、hidden(隐藏字段，用户看不见，但是会被提交到服务器)、image(用一个图形来做一个有提交功能的按钮)带有width和height属性、number(定义输入数字的字段)min规定允许的最小值max允许的最大值。
    * maxlength：规定了input元素中输入的最大字符数。
    * disabled：该input不能够被使用。
    * checked：你还没开始选已经被选中了，用于radio和checkbox中。
    * autofocus:在加了这个属性的input元素中会自动的现实光标，不需要按就直接的可以输入。
    * list：input list=&quot;datalist_id&quot;  datalist和option一起使用可以制作一个下拉列表，但是disabled后被禁用的选项不出 现。
    * 也可以使用select和option来制作下拉列表，optgroup是给option进行分组的。selected属性表示某个option会被默认选中。
    * required：这个input元素中必须填写数据不然不能够提交表单。
    * value：对于不同的type属性值有不同的用法。对于button、reset、submit、定义按钮上的文字；对于text、password、hidden、定义输入字段的初始值；对于checkbox、radio、image定义与元素相关的描述，该值会发送到表单的action URL中。
    * name：设置名字，只有设置了那么属性，的表单元素才能在提交表单时传递它们的值。name属性用于JavaScript中引用元素，或者在表单提交后引用表单数据。
    * placeholder：placeholder描述输入字段预期值的简短的提示信息，该提示会在用户输入值之前显示在输入字段中，placeholder属性适用的input类型有：text、search、url、tel、email和password。
    * readonly：属性规定输入的内容不能够进行修改，防止用户对值进行修改。
    * size：输入的input元素你可以看得见的宽度，实际可以输入的字符还是由maxlength来决定的。
    * step：指定了合法数字间的输入间隔，如果step为3的时候，那么输入数字的间隔就是3，所输入的数字就是3的倍数。
    * 可以使用label来和radio和checkbox一起使用，用来提高用户的体验，使可点击的区域变大。
</code></pre><ul>
<li>button：定义一个按钮。在button元素内部，你可以放置内容，比如文本或图像，这是该元素和input type=button元素创建按钮的区别。如果button不写type属性，表单中首个无type的button的type属性默认为是submit。</li>
<li>aitical：标签定义的内容必须是有意义的且必须是独立于文档的其余部分，来源论坛帖子，博客文章，行文故事，评论。</li>
<li>描述列表：dl、dt、dd、三个一起使用，一个dt可以对应多个dd。</li>
<li>base:为页面上的所有的相对链接地址规定默认URL或默认目标，在一个文档中，最多能使用一个base元素，而且必须置于head元素内部。如果使用了base标签，泽必须具备href属性或者target属性，或者两个属性都具备。</li>
<li>制作表格用到的三个元素：tr、th、td，th表示表头，tr表示有几行，th表示有几列。col元素中span表示col应该横跨的列数。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/11/25/HTML/" data-id="cjbi2n1yb00035nol4tq4jo13" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/22/jQuery-1/">jQuery</a>
          </li>
        
          <li>
            <a href="/2017/12/18/jQuery/">jQuery</a>
          </li>
        
          <li>
            <a href="/2017/12/14/DOM/">DOM</a>
          </li>
        
          <li>
            <a href="/2017/12/11/Array/">Array</a>
          </li>
        
          <li>
            <a href="/2017/12/10/对象/">JS中的对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 张科家<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>