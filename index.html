<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>charity</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="charity">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="charity">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="charity">
  
    <link rel="alternate" href="/atom.xml" title="charity" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">charity</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-AJAX和跨域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/11/AJAX和跨域/" class="article-date">
  <time datetime="2018-01-11T01:19:36.000Z" itemprop="datePublished">2018-01-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/11/AJAX和跨域/">AJAX和跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><ul>
<li><p>什么是JSONP？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.请求方：一个网站的前端   响应方：服务器</span><br><span class="line">2.请求方动态的创建一个script标签，src指向的是响应方,同时传递一个查询参数?callback = xxxx</span><br><span class="line">3.响应方通过传递的查询参数?callback创建一个形如xxx.call(undefined,&quot;你想要的数据&quot;)</span><br><span class="line">4.请求方接受响应方发出的响应的时候，就会执行xxx.call(undefined.&quot;你想要的参数&quot;)</span><br><span class="line">5.请求方得到了想要的数据，并且删除script。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">请求方的代码：</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;zh-Hans&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/style.css&quot;&gt;</span><br><span class="line">    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;您的账户余额是</span><br><span class="line">        &lt;span id=&quot;amount&quot;&gt;$$$amount$$$&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;button id=&quot;button&quot;&gt;付款&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    button.addEventListener(&apos;click&apos;, (x) =&gt; &#123;</span><br><span class="line">        let script= document.createElement(&apos;script&apos;)</span><br><span class="line">        let functionName = &apos;frank&apos; + parseInt(Math.random()*10000,10)</span><br><span class="line">        //创建一个函数名称，使得传过去的查询参数是一个随机数。</span><br><span class="line">        window[functionName] =(result)=&gt;&#123;</span><br><span class="line">            if(result === &apos;success&apos;)&#123;</span><br><span class="line">                alert(`$&#123;result&#125;`)</span><br><span class="line">                amount.innerText  = amount.innerText - 1</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                alert(faile)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//因为functionName是一个随机数，不确定的因素，所以不能使用functionName.xxx   只能使用[]</span><br><span class="line">        script.src = &apos;http://jack.com:8002/pay?callback=&apos; + functionName//添加查询参数，使得可以知道调用的函数是xxx</span><br><span class="line">        //动态的创建了一个script标签在页面之中。并在成功之后删除该script标签，否则会占用过多的内存。</span><br><span class="line">        document.body.appendChild(script)</span><br><span class="line">        script.onload = function(e)&#123;</span><br><span class="line">            e.currentTarget.remove()</span><br><span class="line">            script.onerror = function(e)&#123;</span><br><span class="line">            e.currentTarget.remove()</span><br><span class="line">            alert(&apos;打钱失败&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       /* image.src = &apos;/pay&apos;</span><br><span class="line">        image.onload=function()&#123;</span><br><span class="line">            alert(&apos;打钱成功&apos;)</span><br><span class="line">            amount.innerText = amount.innerText - 1</span><br><span class="line">        &#125;</span><br><span class="line">        image.onerror =function()&#123;</span><br><span class="line">            alert(&apos;打钱失败failse&apos;)</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">响应方的代码：</span><br><span class="line">if(path === &apos;/pay&apos;)&#123;</span><br><span class="line">    var amount =fs.readFileSync(&apos;./amount&apos;,&apos;utf8&apos;)</span><br><span class="line">    //获取数据库中的amount数据。</span><br><span class="line">    var newAmount = amount - 1</span><br><span class="line">      fs.writeFileSync(&apos;./amount&apos;,newAmount)</span><br><span class="line">      //得到新的数据，并将新的数据存在数据库之中。</span><br><span class="line">      response.setHeader(&apos;Content-Type&apos;, &apos;applycation/script&apos;)</span><br><span class="line">      response.statusCode = 200</span><br><span class="line">	//成功返回状态码200；      response.write(`$&#123;query.callback&#125;.call(undefined,&apos;success&apos;)`)//得到查询参数</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    response.statusCode = 404</span><br><span class="line">    response.setHeader(&apos;Content-Type&apos;, &apos;text/html;charset=utf-8&apos;)</span><br><span class="line">    response.write(&apos;找不到对应的路径，你需要自行修改 index.js&apos;)</span><br><span class="line">    response.end()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面描述的是过程，请求方可以使用jQuery就可以发送JSONP请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">button.addEventListener(&apos;click&apos;, (x) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            url: &quot;http://jack.com:800/pay&quot;,</span><br><span class="line">			// Tell jQuery we&apos;re expecting JSONP</span><br><span class="line">            dataType: &quot;jsonp&quot;,</span><br><span class="line">            // Work with the response</span><br><span class="line">            success: function (response) &#123;</span><br><span class="line">               if(response === &quot;success&quot;)&#123;</span><br><span class="line">                alert(`$&#123;response&#125;`)</span><br><span class="line">                amount.innerText = amount.innerText - 1 </span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                alert(&apos;failse&apos;)</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">* JQuery会帮你创建一个script标签向服务器发送请求，也会创建一个随机的查询参数，也会创建更一个函数，服务器接受到这个函数后并返回这个函数，请求方会调用这个函数。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><ul>
<li><p>AJAX发送请求是怎样出现的呢：</p>
<p>1.用form发送请求会刷新页面或重开页面的。(可以发送get请求或者POST请求)</p>
<p>2.使用a标签发送请求GET请求，也会刷新页面，或者重开页面的。</p>
<p>3.用img标签可以发送GET请求，但是只能以图片的形式展示。</p>
<p>4.用link可以发送GET请求，也只能以CSS或者favicon的形式运行，并且link只能放在页面之中才能够运行的。</p>
<p>5.用script发送请求，只能以脚本的形式运行。</p>
</li>
<li><p>什么是AJAX呢：</p>
<p>1.使用XMLHttpRequest发送请求</p>
<p>2.返回的是XML格式的字符串</p>
<p>3，JS进行解析，并更新局部页面</p>
</li>
<li><p>HTTP中的路径都是绝对路径</p>
</li>
<li><p>使用AJAX发送请求的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let request = new XMLHttpRequest</span><br><span class="line">request.open(&quot;POST&quot;,&quot;/xxx&quot;)//设置请求的路径和请求的格式</span><br><span class="line">request.onreadystatechange = (x)=&gt;&#123;</span><br><span class="line">if(request.readystate === 4)&#123;</span><br><span class="line">   let string = request.responseText</span><br><span class="line">  let object = window.JSON.parse(string)</span><br><span class="line">&#125;else</span><br><span class="line">&#125;</span><br><span class="line">request.sed()  //发送请求</span><br></pre></td></tr></table></figure>
</li>
<li><p>readyState中0表示open（）方法还未被调用；1表示send()方法还未被调用；2表示send()方法已经被调用；3表示正在下载，loading；4表示请求完成。响应返回是分不分返回的，并不是一次性返回的。</p>
</li>
<li><p>同源策略：只有当域名、协议、端口号一模一样的时候才叫同源；才能够发送AJAX请求，不是同源的可以通过CORS也能够使用AJAX发送请求。<code>response.setHeader(&#39;Content-type&#39;,&#39;application/javascript;charset =utf-8&#39;)</code>。除了使用CORS还可以使用的是JSONP来进行跨域。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/11/AJAX和跨域/" data-id="cjcadr3100000vtolnksr5qsr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DOM事件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/03/DOM事件/" class="article-date">
  <time datetime="2018-01-03T00:48:09.000Z" itemprop="datePublished">2018-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/03/DOM事件/">DOM事件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><ul>
<li><p>事件流描述的是从页面中接收事件的顺序；<strong>冒泡事件就是说事件开始的时候由最具体的元素（文档中嵌套最深的那个节点）接收，然后逐级上传到较为不具体的文档</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;DOCUTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">*如果你点击了页面中的div元素，那么这个click事件的传播顺序：div&gt;body&gt;html&gt;document</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>事件捕获：时间捕获是不太具体的节点应该更早的接收到事件，而最具体的节点应该最后接收到事件</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;DOCUTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">* 如果你点击了div元素，那么这个click时间的传播顺序就是document&gt;html&gt;body&gt;div;从最大的到最具体的。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>DOM事件流结合时间冒泡和事件捕获，包括时间捕获阶段、处于目标阶段和事件冒泡阶段</strong>。首先发生的是在捕获阶段，为截事件提供了机会，；然后才是实际的目标接受到事件；最后才是冒泡阶段，可以在这个阶段对事件做出响应。DOM2事件规范明确要求捕获阶段不涉及事件目标，也就是只有在冒泡阶段的时候才会进行事件的处理。</p>
</li>
<li><p>​</p>
<p>​</p>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/03/DOM事件/" data-id="cjcadr3160002vtol9tzxf03a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/01/闭包/" class="article-date">
  <time datetime="2018-01-01T01:40:45.000Z" itemprop="datePublished">2018-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/01/闭包/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>什么是闭包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">闭包就是一个函数可以访问到它外部的变量，那么这个函数和这个变量就组成了一个闭包。</span><br><span class="line">function f1()&#123;</span><br><span class="line">  var n =999</span><br><span class="line">  fucntion f2()&#123;</span><br><span class="line">    alert(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面的函数f2和n组成了一个闭包。</span><br><span class="line">* 也可以说闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常用的方式就是在一个函数的内部创建另一个函数。</span><br><span class="line">function createComparise(propertyName)&#123;</span><br><span class="line">  return function(object1,object2)&#123;</span><br><span class="line">    var value1 = object1[propertuName];</span><br><span class="line">    var value2 = object2[propertyName];//这两个函数访问了函数外的变量proprtyName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在JavaScript中子对象会一级一级的向上寻找所有的父对象的变量，。所以父对象的所有变量对子对象都是可见的，反之子对象的所有变量对于父对象都是不可见的。这就是JavaScript语言特有的『链式作用域』结构。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fucntion f1()&#123;</span><br><span class="line">  var n =999;</span><br><span class="line">  function f2()&#123;</span><br><span class="line">    alert (n)</span><br><span class="line">  &#125;</span><br><span class="line">  return f2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result =f1();</span><br><span class="line">result();//999</span><br><span class="line"></span><br><span class="line">* 在上面的代码中函数f2就是闭包，一般闭包最常用的就是在一个函数中生成另一个函数的，返回一个函数，这样在外部就可以访问到内部的变量了。</span><br></pre></td></tr></table></figure>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><ul>
<li><p>闭包的第一个作用是可以在函数作用域外部读取到函数内部的变量；二就是可以让这些变量可以始终的保存在内存中。还可以封装私有属性和私有方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">　　function f1()&#123;</span><br><span class="line">　　　　var n=999;</span><br><span class="line">　　　　nAdd=function()&#123;n+=1&#125;</span><br><span class="line">　　　　function f2()&#123;</span><br><span class="line">　　　　　　alert(n);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　return f2;</span><br><span class="line">　　&#125;</span><br><span class="line">　　var result=f1();</span><br><span class="line">　　result(); // 999</span><br><span class="line">　　nAdd();</span><br><span class="line">　　result(); // 1000</span><br><span class="line">* 在这段代码中result一共调用了两次的了，第一次的值是999，第二次的值是1000，这证明的了函数f1中的局部变量n一直保存在变量中，并没有在f1调用后被自动清除。在上面的代码中nAdd=fucntion()&#123;n+=1;&#125;这一行并没有使用var声明，所以是一个全局变量，不是一个局部变量，而且也是一个闭包，可以在函数外部对函数内部的变量进行操作。</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用闭包注意的问题</p>
<p>1.闭包会使函数中的变量保存在内存之中，对内存的消耗很大，不能滥用闭包，否则会造成网页的性能的问题。</p>
<p>2.闭包会在父函数的外部改变函数内部变量的值。</p>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/01/01/闭包/" data-id="cjcadr31c000cvtol27q4peen" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/30/HTTP/" class="article-date">
  <time datetime="2017-12-30T07:40:14.000Z" itemprop="datePublished">2017-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/30/HTTP/">HTTP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>HTTP(HyperTest Transfer Protocol)超文本传输协议。Web使用HTTP的协议作为规范，完成从客户端到服务器端等一系列运作流程，可以说Web是建立在HTTP协议通讯上的。</li>
<li>Tim.Berners-Lee(李爵士)创建了万维网，当时提出了3项WWW的构建技术就是：页面文本的标记语言HTML；作为传输协议的HTTP；指定文档所在地址的URL（Uniform Resource Locator统一资源定位符）。</li>
<li>不同的硬件、操作系统之间的通信之间需要一种规则，我们把这种规则称之为协议（Protocol）。协议中存在各种各样的内容，把互联网相关的协议集合起来总称为TCP/IP。而HTTP则是在TCP/IP协议族的基础上运行的，HTTP属于他内部的一个子集。</li>
<li>IP协议作用就是将各种数据包传递给对方。而要保证确实传送到对方哪里需要满足各种条件，其中最重要的就是IP地址和MAC地址。</li>
<li>IP地址是指明了节点被分配到的地址，是可以变换的，MAC地址（Media Access Control Address）基本上不会更改。</li>
<li>ARP是一种以解析地址的协议；根据通信方的IP地址就可以查到相对应MAC地址。</li>
<li>TCP协议的三次握手是为了确保通信的可靠信，数据的传输过程中。发送端发送一个SYN标志的数据包给对方，接收端收到后，回传一个带有SKN/ACK标志的数据包以表示传达确认信息，最后发送端再回传一个带有ACK标志的数据包，戴白哦握手结束。</li>
<li>DNS(Domain Name System)是和HTTP协议一样位于应用层的协议，提供域名到IP地址之间的解析服务。</li>
</ul>
<h2 id="URI（Uniform-Resource-Identifier）统一资源标识符"><a href="#URI（Uniform-Resource-Identifier）统一资源标识符" class="headerlink" title="URI（Uniform Resource Identifier）统一资源标识符"></a>URI（Uniform Resource Identifier）统一资源标识符</h2><ul>
<li><p>URI就是由某个协议方案表示的资源的定位标识符，协议方案是指访问资源的时候所使用的协议类型的名称。</p>
</li>
<li><p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上所处的位置），由此可见URL是URI的子集。</p>
</li>
<li><p>URI包括URL和URN，其中URL就是我们常说的网址。</p>
</li>
<li><p>URL包括：</p>
<p>1.协议（一般是http/https协议）</p>
<p>2.域名：www.baidu.com，顶级域名是最后一个.右边部分，二级域名是一次往下输的就是，.com是顶级域名，baidu是二级域名，www是三级域名。</p>
<p>3.端口号：一般是80</p>
<p>4.路径：</p>
<p>5.查询参数？。。。。</p>
<p>6.锚点：</p>
</li>
</ul>
<h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><ul>
<li><p>客户端和服务器通过HTTP协议进行交互</p>
</li>
<li><p>浏览器发起请求，服务器在80端口接受请求，服务器返回内容(响应)，浏览器负责下载响应的内容。HTTP的作用就是直到浏览器和服务i去如何进行沟通。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1 动词 路径 协议/版本</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Key3: value3</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line">3 </span><br><span class="line">4 要上传的数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Frank: xxx</span><br><span class="line"></span><br><span class="line">curl -X POST -s -v -H &quot;Frank: xxx&quot; -- &quot;https://www.baidu.com&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Frank: xxx</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">1234567890</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应的格和内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 2443</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Tue, 10 Oct 2017 09:14:05 GMT</span><br><span class="line">Etag: &quot;5886041d-98b&quot;</span><br><span class="line">Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line">Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略了……</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1 协议/版本号 状态码 状态解释</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Content-Length: 17931</span><br><span class="line">2 Content-Type: text/html</span><br><span class="line">3</span><br><span class="line">4 要下载的内容</span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTP状态码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* 1xxx不常用，表示接受的请求正在处理</span><br><span class="line">* 2xx表示成功</span><br><span class="line">	2.200表示客户端发来的请求在服务器端被正常的处理。</span><br><span class="line">	2.204代表服务器接受的请求已成功的处理，但在返回的响应报文中不包含实体的主题部分。</span><br><span class="line">	3.206表示客户端进行了范围请求，服务器成功的执行了这部分的请求。</span><br><span class="line">* 3xx表示重定向</span><br><span class="line">	1.301永久性重定向，该状态码表示请求的资源已经被分配了新的URL以后应该使用资源现在所指定的URL，</span><br><span class="line">	2.302临时性重定向，该状态码表示请求的资源已经被分配了新的URL，希望用户本次使用新的URI访问。</span><br><span class="line">	3.303该状态码表示请求对应的资源存在着另一个URL，应该使用GET方法定向获取请求的资源。</span><br><span class="line">	4.304该状态码表示客户端发送附带条件的请求的时候，服务器端允许请求访问资源。单因发生请求请求未满足条件的情况后，直接返回304Not Modefied。</span><br><span class="line">	5.307表示临时重定向，</span><br><span class="line">* 4xx表示客户端的错误</span><br><span class="line">	1.400该状态码表示请求报文中存在着语法错误。当错误发生时应该修改请求的内容后再次发送请求。</span><br><span class="line">	2.401该状态码表示发送的请求需要有HTTP认证的认证消息。另外若之前已经进行过一次请求，则表示用户认证失败。</span><br><span class="line">	3.403Forbidden该状态码表示对请求资源的访问被服务器拒绝了。</span><br><span class="line">	4.404 Not Found表示服务器上没有请求的资源。</span><br><span class="line">* 5xx表示服务器错误</span><br><span class="line">	1，500改状态吗表示服务器在执行请求的时候发生错误，</span><br><span class="line">	2.503改状态码表示服务器暂时处于超负荷或正在进行停机维护。</span><br></pre></td></tr></table></figure>
</li>
<li><p>从输入URL到页面加载显示完成都发生了什么:</p>
<p>1.浏览器根据域名查找对应的IP地址，也就是DNS解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 每个域名都对应了一个或者多个提供相同服务的IP地址，只有直到服务器的IP地址才能够建立连接，所以需要桶过DNS把域名解析成一个IP地址。域名的解析过程是递归查询的，首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会想根域名服务器发送一个请求，如果根域名服务器也不存在该域名的时候，本地域名会向com顶级域名服务器发送一个请求，如果顶级域名服务器没有就会到耳机域名服务器查询，以此类推，直到最后本地域名服务器得到了域名的IP地址并把它缓存到本地，供下次查询使用。</span><br><span class="line">* DNS缓存，DNS存在着多级缓存，从离浏览器的距离排序的话可以分为：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存，主域名服务器缓存。</span><br><span class="line">* DNS负载均衡：真实的互联网的有很多的服务器，你每次访问网站的IP地址都是不一样的。DNS返回一个合适的机器的IP地址给用户，例如根据每台机器的负载量，该机器距离用户地理位置等。</span><br></pre></td></tr></table></figure>
<p>2.TCP连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 浏览器于服务器之间通过三次握手建立TCP连接；为什么要建立三次握手呢，原因是两次握手不可靠。原因是两次握手不可靠。比如，浏览器发送一个连接请求包A，但包A在半路上堵车了，浏览器就认为包A丢失了，所以重新发生一个请求包B给服务器。服务器收到请求，建立连接。两端进行通信，结束后关闭连接。但是这时候，包A到达了服务器，服务器不知道这是一个无效的包，所以进行响应。这时两次握手已经完成，两端就建立起一个无效的连接。但浏览器认为自己没发出请求，所以不会回应，这样就让服务器白白等待回应，浪费了服务器资源。而三次握手的机制下，浏览器知道自己并没有请求连接，会发送拒绝包给服务器，服务器收到回应后也会结束这次无效的连接。</span><br></pre></td></tr></table></figure>
<p>3.浏览器向服务器发送HTTP请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure>
<p>4.服务器接受到请求，从它的文档空间中查找资源并返回HTTP响应</p>
<p>5.浏览器接受HTTP响应，检查HTTP header里面的状态码，并做出不同的处理方式。如果是可以缓存的，这个响应则会被存储下来。</p>
<p>6.解码：浏览器拿到文件后，开始解析其中的html代码，遇到js/css/image等静态资源的时候就向服务器端去请求下载。</p>
<p>7.渲染：</p>
<p>8.关闭TCP连接或继续保持连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 通过四次挥手关闭连接：第一次挥手是浏览器发完数据后，发送FIN请求断开连接。第二次挥手是服务器发送ACK表示同意，如果在这一次服务器也发送FIN请求断开连接似乎也没有不妥，但考虑到服务器可能还有数据要发送，所以服务器发送FIN应该放在第三次挥手中。这样浏览器需要返回ACK表示同意，也就是第四次挥手。</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/30/HTTP/" data-id="cjcadr3170003vtoldm9pm7af" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/22/jQuery-1/" class="article-date">
  <time datetime="2017-12-22T09:24:15.000Z" itemprop="datePublished">2017-12-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/22/jQuery-1/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="jQuery和DOM之间的转换"><a href="#jQuery和DOM之间的转换" class="headerlink" title="jQuery和DOM之间的转换"></a>jQuery和DOM之间的转换</h2><ul>
<li>DOM对象和jQuery之间的转换，DOM对象可以通过jQuery进行包装成jQuery对象，$()，就可以将DOM对象包装成jQuery对象的了。jQuery对象通过[index]的方式可以将jQuery对象抓换位DOM对象。$(div)[0]=div,可以这样进行转换。</li>
<li>全局变量尽量少用，尽量使用局部变量。声明一个函数立即执行，function f(){}.call()，这样可以，局部变量的作用域只是在函数的内部，在函数 外面就不能访问到函数里面的变量。但是创建了一个函数并且立即执行这样浏览器会报错的，在function前面加一些符号就可以避免这个错误的了，还可以使用的是，{let a=1}用一个代码块，使用<code>let</code>来声明一个变量。在这个代码块外面如果没有声明a，console.log(a)会打印出undefined。</li>
</ul>
<h2 id="轮播的思路"><a href="#轮播的思路" class="headerlink" title="轮播的思路"></a>轮播的思路</h2><ul>
<li><p>让所有的轮播图在一行里面，轮播图窗口的大小就是一张图片的大小，在窗口之外的图片使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 使用jQuery获取到所有的元素，找到所有点击的图标的下标，每个看每个移动的距离乘以得到的下标就是每个图片所需要移动的距离。</span><br><span class="line"></span><br><span class="line">*</span><br></pre></td></tr></table></figure></p>
<p>var buttons = $(‘#button &gt; span’)<br>var n = 0;<br>//.eq意思是找出对应的DOM对象，并封装成一个jQuery对象。<br>buttons.eq(n % 3).trigger(‘click’).addClass(‘red’)<br>.siblings(‘.red’).removeClass(‘red’)<br>var timerId = setInterval(() =&gt; {<br>   n += 1<br>   buttons.eq(n % 3).trigger(‘click’).addClass(‘red’)<br>   .siblings(‘.red’).removeClass(‘red’)<br>}, 1000)<br>$(‘.screen’).on(‘mouseenter’, function () {</p>
<pre><code>window.clearInterval(timerId)
</code></pre><p>})<br>$(‘.screen’).on(‘mouseleave’, function () {</p>
<pre><code>timerId = setInterval(() =&gt; {
    n += 1
    buttons.eq(n % 3).trigger(&apos;click&apos;).addClass(&apos;red&apos;)
        .siblings(&apos;.red&apos;).removeClass(&apos;red&apos;)
}, 1000)
</code></pre><p>})<br>```</p>
</li>
</ul>
<h2 id="写代码的原则"><a href="#写代码的原则" class="headerlink" title="写代码的原则"></a>写代码的原则</h2><ul>
<li>JS内容、样式、行为的分离。其中HTML负责内容，CSS负责样式，JavaScript负责行为，这是写代码的原则。但是原则有时候也可以打破的，不是一定必须要这么坚持的原则，但是坚持原则也是比较好的一种行为的。</li>
</ul>
<h2 id="无缝轮播的思路"><a href="#无缝轮播的思路" class="headerlink" title="无缝轮播的思路"></a>无缝轮播的思路</h2><ul>
<li>联想到生活中的跳绳，先让图片排成一排，然后再每个都从敞口过一遍，之后呢，每个再回到第一次的位置，就这样一直轮着下去，就实现一个无缝的轮播，这样要使用的display：absolute；使每个图片都不相互干扰。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/22/jQuery-1/" data-id="cjcadr3180006vtollizx0uq0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/18/jQuery/" class="article-date">
  <time datetime="2017-12-18T04:45:55.000Z" itemprop="datePublished">2017-12-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/18/jQuery/">jQuery</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="自己实现一个jQuery的思路和代码"><a href="#自己实现一个jQuery的思路和代码" class="headerlink" title="自己实现一个jQuery的思路和代码"></a>自己实现一个jQuery的思路和代码</h2><ul>
<li>自己实现一个API的思路和代码</li>
</ul>
<ul>
<li><p>1.包装两个函数，添加一个className和获取一个文本内容</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function addClass(node,className)&#123;  className.forEach((value)=&gt;node.classList.add(value))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function text(node)&#123;</span><br><span class="line"></span><br><span class="line">  return text =node.innerText</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addClass(iterm1,[1,2,3])</span><br><span class="line"></span><br><span class="line">console.log(text(iterm3))</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>2.给函数起一个名字，可以用命名空间来取windon.zkjDOM={};zkjDOM.addClass=addClass;zkjDOM.text=text;有可能别人也起了一个这样的函数名字，就把别人的函数给覆盖了；还可以直接将函数添加到Node.prototype中去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- Node.prototype.addClass = function (node,className)&#123;  className.forEach((value)=&gt;node.classList.add(value))&#125;,还可以新建一个Node，window.Node2 =function(node)&#123;return addClass:&#123;&#125;,text:&#123;&#125;&#125;,</span><br><span class="line">  window.Node2 = function(node)&#123;</span><br><span class="line">    return&#123;addClass: function(className)&#123;className.forEach((value) =&gt; node.classList.add(value))&#125;,</span><br><span class="line">  getText : function()&#123;return text = node.textContent&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>3.使用字符串去查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">window.Node2 = function(nodeorSelector)&#123;</span><br><span class="line"></span><br><span class="line">let node</span><br><span class="line"></span><br><span class="line">  if(typeof nodeorSelector===&apos;string&apos;)&#123;</span><br><span class="line"></span><br><span class="line">node = document.querySelector(nodeorSelector)</span><br><span class="line"></span><br><span class="line">  &#125;else if(nodeorSelector instanceof Node)&#123;</span><br><span class="line"></span><br><span class="line">node =nodeSelector&#125;</span><br><span class="line"></span><br><span class="line">return&#123;</span><br><span class="line"></span><br><span class="line">addClass: function(className)&#123;</span><br><span class="line"></span><br><span class="line">className.forEach((value) =&gt; node.classList.add(value))</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">getText : function()&#123;return text = node.textContent</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var node2 = Node2(&quot;#iterm2&quot;)</span><br><span class="line"></span><br><span class="line">node2.addClass([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])</span><br><span class="line"></span><br><span class="line">console.log(node2.getText())</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><p>可以查找多个并：</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- window.jQuery = function(nodeorSelector)&#123;</span><br><span class="line">  let nodes=&#123;&#125;</span><br><span class="line">  if(typeof nodeorSelector===&apos;string&apos;)&#123;</span><br><span class="line">  let temp = document.querySelectorAll(nodeorSelector)</span><br><span class="line">  for(let i= 0;i&lt;temp.length;i++)&#123;</span><br><span class="line">  nodes[i]=temp[i]</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.length = temp.length</span><br><span class="line">  &#125;else if(nodeorSelector instanceof Node)&#123;</span><br><span class="line">  node =&#123;0:nodeorSelector,length:1&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.addClass = function(className)&#123;className.forEach((value) =&gt; &#123;</span><br><span class="line">  for(let i=0;i&lt;nodes.length;i++)&#123;</span><br><span class="line">  nodes[i].classList.add(value)</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.getText =function()&#123;</span><br><span class="line">  let texts =[]</span><br><span class="line">  for(let i=0;i&lt; nodes.length;i++)&#123;</span><br><span class="line">  texts.push(nodes[i].innerText)</span><br><span class="line">  &#125;</span><br><span class="line">  return texts</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText =function(text)&#123;</span><br><span class="line">  for(i=0;i &lt; nodes.length;i++)&#123;</span><br><span class="line">  nodes[i].innerText = text</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  return nodes</span><br><span class="line">  &#125;</span><br><span class="line">  var node2 = jQuery(&quot;div&quot;)</span><br><span class="line">  console.log(node2)</span><br><span class="line">  node2.addClass([&apos;a&apos;])</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/18/jQuery/" data-id="cjcadr31d000evtol9lsr9u5v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/14/DOM/" class="article-date">
  <time datetime="2017-12-14T11:40:50.000Z" itemprop="datePublished">2017-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/14/DOM/">DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li><p>DOM是JavaScript操作网页的接口，全称为Document Object Model，也就是文档对象模型，它的作用试讲网页转为一个JavaScript对象，从而可以用脚本进行各种操作。浏览器会根据DOM模型，将结构化文档解析成一系列的节点，再由这些节点组成一个树状结构，也就是DOM tree。</p>
</li>
<li><p>节点的类型有七种类型：</p>
<p>1.Document类型整个文档树的顶层节点</p>
<p>2.DocumentType:doctype标签，比如&lt;!DOCTYPE html&gt;</p>
<p>3.Element:网页的各种HTML标签</p>
<p>4.Attribute：网页元素的属性（如class:’right’）</p>
<p>5.Text:标签之间或标签包含的文本</p>
<p>6.Comment:注释</p>
<p>7.DocumentFragment:文档的片段</p>
</li>
<li><p>DOM的最小组成单位是节点node。最顶层的节点就是document节点，它代表了整个文档。文档里面的最高一层的HTML标签，一班是<code>&lt;html&gt;</code>，它构成了树结构的根节点（root node），其他HTML标签节点都是它的下级。</p>
</li>
<li><p>页面中的节点通过构造函数构造出对应的对象，这就是DOM的主要功能。</p>
</li>
<li><p>Node的属性</p>
<p>1.childNodes表示所有的子节点</p>
<p>2.nodeName返回的都是字符串，除了svg以外，所有的都是大写的返回值。</p>
<p>3.获取html要使用<code>document.document.element</code>,</p>
<p>4.nodeType，值是1的时候表示的是element，值是3的时候表示的是Text，值是9的时候表示document。</p>
<p>5.innertext只会获取文本，而textContent除了获取文本以外还会获取script和style元素。</p>
<p>6.cloneNode表示克隆节点，后面接受一个参数表示是否接受深拷贝。true表示接受，false表示不接受深拷贝。</p>
<p>7.isEqualNode表示相等的两个节点，isSameNode表示相同的两个节点，可以理解位就是同一个节点才会是相同的。</p>
<p>8.removeChild表示移除子节点，但是还是会在内存中，可以被调用的。</p>
</li>
<li><p>Docucment接口：</p>
<p>1.body获取body元素</p>
<p>2.characterSet获取字符编码</p>
<p>3.documentElement获取的就是html元素，是文档的根元素。</p>
<p>4.document.domain获取你的域名</p>
<p>5.document.links获取页面中所有的a标签。</p>
<p>6.document.plugins获取是否装了插件</p>
<p>7.referrer引荐人</p>
<p>8.visibilityStates表示页面是否可以显示</p>
<p>9.document.execCommand（）表示执行命令</p>
<p>10.document.qurySelector()返回一个元素，但是document.querySelectorAll()返回的是一个伪数组，不管里面的有几个都是一个伪数组，原型指向的是NodeLise.prototype</p>
</li>
<li><p>element接口</p>
<p>1.attribute返回一个和该元素相关的所有属性的集合</p>
<p>2.accessKey设置一个按键，用户桶过敲击这个按键吧焦点跳转到这个元素上。</p>
<p>3.clientLeft表示一个元素左边框的宽度</p>
<p>4.clientTop获取一个元素顶部的距离</p>
<p>5.innerHTML和textContent的区别是textContent只获取到文本，innerHTML是可以获取到里面的标签。</p>
<p>6.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/14/DOM/" data-id="cjcadr3140001vtoltsyy9kw9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/11/Array/" class="article-date">
  <time datetime="2017-12-11T05:26:10.000Z" itemprop="datePublished">2017-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/11/Array/">Array</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><ul>
<li>数组就是一组有序集合，在JS中的数组就是原型链中有Array.prototype的对象。数组恩每个值都有自己对应的编号(从0开始)，整个数组用方括号表示。</li>
<li>生成数组的方式有两种：一种是直接用[]来生成，第二种是使用new Array来生成数组，这两种方法生成的。其中使用new Array和使用Array来生成数组是一样的。</li>
<li>有一点是要注意的，当使用Array构造汗数来生成数组的时候，当你传入的参数位一个的时候，这个时候你只能生成一个length为传入参数的空数组，每一项的值都是undefined。当你传入的参数多于一个的时候生成的数组的值就是你穿如的参数，数组的length就是你穿如参数的个数。</li>
<li>![Alt  text][./数组.png]</li>
</ul>
<h3 id="函数声明的方式"><a href="#函数声明的方式" class="headerlink" title="函数声明的方式"></a>函数声明的方式</h3><p>1.具名函数</p>
<figure class="highlight plain"><figcaption><span>f (x,y)&#123;return x + y&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.匿名函数加var</p>
<figure class="highlight plain"><figcaption><span>f ; f </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.具名函数加var </p>
<figure class="highlight plain"><figcaption><span>f1 ; f1 </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>4.window.Function +var </p>
<figure class="highlight plain"><figcaption><span>f ; f </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5.箭头函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h2><ul>
<li>什么是伪数组：就是有0，1，2，3，4，5…..n，length这些key的对象，但是原型链中没有Array.prototype。目前直到的伪数组有arguments对象，和document.querySelectAll返回的对象。</li>
</ul>
<h2 id="数组中的API"><a href="#数组中的API" class="headerlink" title="数组中的API"></a>数组中的API</h2><ul>
<li>Array.peototype.forEach,后面接一个函数，表示对数组中的每一个元素执行一次所对应的函数。</li>
<li>Array,prototype.Sort后面接一个函数，函数接受两个参数，分别是数组中的两个值，返回值位两个值的差。如果大于0 则按照从小到大的顺序对数组进行排列，如果小于0的话，则按照从大到小的顺序排列。</li>
<li>Array.prototype.join用于将一个数组的所有元素连接到一个字符串中，返回值是一个字符串。</li>
<li>Array.prototype.Concat用于节哀那个两个数组合并为一个数组，返回一个新的数组，但不会更改现有的数组。</li>
<li>Array.prototype.toString用于将一个数组转为字符串</li>
<li>Array.prototype.map用于创建一个新数组，七街狗是该数组中的每一个元素都调用一个提供的函数后返回的结果。</li>
<li>Array.prototype.filter后面接一个函数，用来将一个数组特定的值过滤出来。</li>
<li>Array.prototype.reduce后面接一个函数，接两个参数，第一个是前面累加的值，第二个是正咋处理的元素，这个API的用法就是用来求和的，你可以将这个想象成抢劫的应用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/11/Array/" data-id="cjcadr3180005vtolxxjjeb0p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/10/对象/" class="article-date">
  <time datetime="2017-12-10T04:25:56.000Z" itemprop="datePublished">2017-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/10/对象/">JS中的对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS中的对象"><a href="#JS中的对象" class="headerlink" title="JS中的对象"></a>JS中的对象</h1><h2 id="什么是全局对象和全局变量"><a href="#什么是全局对象和全局变量" class="headerlink" title="什么是全局对象和全局变量"></a>什么是全局对象和全局变量</h2><ul>
<li><p>ECMAScript中规定全局对象是global，但是在浏览器中全局对象是window，不管你在哪个网页一定可以访问到一个对象，就是window。window是一个hash表，有很多属性，这些属性就是全局对象。</p>
</li>
<li><p>window中的属性包含两种，一种是ECMAScript规定的，不管是在Node.js还是在浏览器中都要有这些属性；另一种则是浏览器私有的，就是在某些浏览器中才有的一些属性。每个浏览器的私有属性的标准都是不一样的，因为没有标准的规定，所以不一样。</p>
<p>1.ECMAScript规定的</p>
<ul>
<li>global.parseInt      (将字符串转为数字，接受两个参数，第一个是要转换的字符串，第二是转换的进制数)</li>
</ul>
</li>
</ul>
<ul>
<li>global.parseFloat    (将字符串转为浮点数)</li>
</ul>
<ul>
<li>global.Number    (将别的类型的值转为Number  数字)</li>
<li>Global.String    (将别的类型的值转为String 字符串)</li>
<li>global.Boolean   (将别的类型的值转为Boolean 布尔值)</li>
<li><p>global.Object    (将别的类型的值转为Object 对象)</p>
<p>2.浏览器自己加的属性</p>
</li>
</ul>
<ul>
<li>window.alert   (弹框提示)</li>
<li>window.promt  (让用户填东西)</li>
<li>window.confirm  (让用户确认)</li>
<li>window.console.log   (让开发者打印东西)</li>
<li>window.console.dir  (打印出对象所有的属性)</li>
<li>window.document (也有自己的规范也就是DOM，是由W3C指定的规范)</li>
<li>window.document.createElement (再文档中创建新的元素)</li>
<li>window.docuemnt.getElementById   (获取文档中有这个id的元素)</li>
</ul>
<h2 id="JS中简单类型和对象的区别"><a href="#JS中简单类型和对象的区别" class="headerlink" title="JS中简单类型和对象的区别"></a>JS中简单类型和对象的区别</h2><ul>
<li><p>Number的用法有两种：</p>
<p>1.将一个字符串”1”转换位数字1</p>
<p>2.作为一个构造函数创建一个对象1，<code>var n = new Number(1)</code></p>
</li>
<li><p>简单类型的1和对象的的区别是在内存中,简单类型的1是直接存在stack内存中的，而对象1在stack中存了这个对象地址，而对象是存在heap内存中的，，这个对象其实是一个hash，包含了Number对象的各种属性，这个对象1要调用对象中的属性时，就通过stack中的地址找到heap中的对象，使用对象中的属性。那么简单类型的1为什么也可以使用Number中的属性呢？原因就是在简单类型1使用Number的方法的时候，会将简单类型1封装成一个临时对象，然后再调用Number对象中的属性。这个临时的对象在使用完成以后会被删除回收掉。</p>
</li>
<li><p>String的用法也是有两种：</p>
<p>1.将一个别的类型的值转为字符串</p>
<p>2.作为构造函数，创建一个字符串对象 <code>var s = new String(&#39;sdkkhfkdljfk&#39;)</code>;这个对象中有很多的属性，<code>s.charAt(1) =d</code>获取某一个索引对应的字符，s.<code>charCodeAt(0)=115</code>,获取某个索引对应字符的Unicode编码的数字，<code>(100).toString(16) = 64</code>表示将数字100转为16进制位64。<code>trim(),&#39;   username  &#39;.trim();返回值为&quot;username&quot;去掉字符串中的空格</code>，<code>concat()连接两个字符串，var s= &#39;hello&#39;; var s1 = &#39;world&#39;; s.concat(s1)=&#39;hello world&#39;</code>,<code>var a = &#39;hello&#39;; a.slice(0,3)返回&quot;hel&quot;</code>,<code>var a = &#39;hello&#39;;e.replace(&#39;o&#39;);返回&quot;hollo&quot;</code>。</p>
</li>
<li><p>Boolean的用法也是两种：</p>
<p>1.将别的类型转为布尔值，其中五个falsy值，”0”、”AaN”、””(空字符串)、”null”、”undefined”;</p>
<p>2.作为构造函数，穿件一个对象，所有的对象都是true,</p>
</li>
<li><p>Object:就是创建一个函数。</p>
</li>
</ul>
<h2 id="共有属性"><a href="#共有属性" class="headerlink" title="共有属性"></a>共有属性</h2><ul>
<li>String.prototype是String的公有属性的引用，如果没有就不能引用String的共有属性，会被垃圾回收，而<code>s.__proto__</code>是为了要使用String的公有属性，如果没有<code>__proto__</code>就不能够引用String的共有属性。</li>
<li><img src="/Users/kejia/Desktop/JS中的对象.png" alt="JS中的对象"></li>
<li>​</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/10/对象/" data-id="cjcadr31m000gvtoluaa7lfjx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-函数" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/09/函数/" class="article-date">
  <time datetime="2017-12-09T08:05:28.000Z" itemprop="datePublished">2017-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/09/函数/">函数</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="函数声明的物种方式"><a href="#函数声明的物种方式" class="headerlink" title="函数声明的物种方式"></a>函数声明的物种方式</h2><p>1.关键字声明一个具名函数<figure class="highlight plain"><figcaption><span>x (x,y)&#123;return x+y&#125;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.function声明一个匿名函数```var a = function (x,y)&#123;return undefined&#125;```但是必须要先声明一个变量把这个函数赋值给这个变量。```a.name = &quot;a&quot;</span><br></pre></td></tr></table></figure></p>
<p>3.使用var 声明一个变量 并赋值一个具名函数<figure class="highlight plain"><figcaption><span>x </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.window.Function()来生成，```var f = new function(&apos;x&apos;,&apos;y&apos;,&apos;return x + y&apos;)f.name = &quot;anonymous&quot;</span><br></pre></td></tr></table></figure></p>
<p>5.箭头函数,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 函数的调用</span><br><span class="line">* 函数的调用的方法有两种，f(),和f.call()。f.call()接受三个参数，第一个是this，从第二个开始才是函数接受的参数。</span><br><span class="line">* f 和f.call的区别是f指的是函数对象，f.call是用eval执行函数体。eval()是将传入的字符串当代码执行。</span><br><span class="line">* 可以执行代码就是一个函数，可以这样对函数定义。</span><br><span class="line">* f()和f.call(undefined,1,2)这两种方法可以调用函数。使用f.cals()第二个开始后面才是传的参数。</span><br><span class="line"></span><br><span class="line">## this和arguments</span><br><span class="line">* ```function z (x,y)&#123;return x + y &#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>```f.call(undefined,1,,2)```这种调用中第一个参数就是this，后面的参数就是arguments。
arguments是一个伪数组，```__proto__```没有指向```Array.prototype```.
</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul>
<li>函数的作用域就是这个函数内部。</li>
<li>变量提升：var和function都会被提升到头部。<code>var a =  3;</code>其实是两个语句<code>var a ;a = 3;</code>。</li>
<li><code>var a = 0; function f1(){alert(a);var a = 2};f1.call()</code>这个中alert(a)的值是udefined，因为其中var = a 会被变量提升到f1的顶部，但是此时的a并没有赋值，只是被声明了，所以执行alert(a)会是undefined。</li>
<li><code>var a  = 1 ; function f1(){var a = 2; f2.call()};function f2(){console.log(a)}</code>,这个中console.log(a)会打印出1，执行f1函数的时候里面有f2.call(),这是会执行f2,f2里面只有console.log(a),但是f2中没有声明变量a，就会在f2的上一层找，也就是a = 1,所以打印出来的是1.</li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li>定义就是一个函数使用它范围外的变量，那么这个函数+变量就是一个闭包。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/09/函数/" data-id="cjcadr31e000fvtol93xjmovc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/11/AJAX和跨域/">AJAX和跨域</a>
          </li>
        
          <li>
            <a href="/2018/01/03/DOM事件/">DOM事件</a>
          </li>
        
          <li>
            <a href="/2018/01/01/闭包/">闭包</a>
          </li>
        
          <li>
            <a href="/2017/12/30/HTTP/">HTTP</a>
          </li>
        
          <li>
            <a href="/2017/12/22/jQuery-1/">jQuery</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 张科家<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>